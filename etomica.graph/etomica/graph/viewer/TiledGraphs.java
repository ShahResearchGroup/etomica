package etomica.graph.viewer;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.HeadlessException;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;

import org.apache.batik.bridge.UpdateManager;
import org.apache.batik.dom.svg.SVGDOMImplementation;
import org.apache.batik.svggen.SVGGeneratorContext;
import org.apache.batik.svggen.SVGGraphics2D;
import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.swing.JSVGScrollPane;
import org.apache.batik.swing.svg.JSVGComponent;
import org.apache.batik.transcoder.Transcoder;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderInput;
import org.apache.batik.transcoder.TranscoderOutput;
import org.apache.batik.transcoder.svg2svg.SVGTranscoder;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.svg.SVGDocument;

import etomica.graph.model.Edge;
import etomica.graph.model.Graph;
import etomica.graph.view.rasterizer.DestinationType;
import etomica.graph.view.rasterizer.Main;
import static etomica.graph.model.Metadata.*;

// TODO: generate the SVGs by hand (seems much faster and the pattern is simple enough)
// TODO: fix the hovering feature taking into account the position of the scrollbar
// TODO: fix the scrolling of the document- perhaps including a large rectangle at the bottom layer
// including all graphs could avoid this.
public class TiledGraphs {

  private static final int defaultBorder = 8;
  private static final int defaultGutter = 12;
  private static final int nodeRadius = 10;
  private static final int graphRadius = 40;
  private static final int clusterHeight = 82;
  private static final int clusterWidth = 82;

  private static final Stroke SELECTED_STROKE = new BasicStroke(1.5f, BasicStroke.CAP_SQUARE,
      BasicStroke.JOIN_MITER, 1.0f, new float[] { 3, 5 }, 3);
  private static final Color SELECTED_COLOR = Color.DARK_GRAY;
  private static final Stroke HOVERING_STROKE = new BasicStroke(1.5f);
  private static final Color HOVERING_COLOR = Color.MAGENTA;

  private JSVGCanvas canvas;

  private int clustersAcross;
  private int clustersAlong;
  private int height;
  private JFrame frame;
  private Set<Graph> graphs;

  private SVGDocument svg;
  private List<Rectangle2D> tiles = new ArrayList<Rectangle2D>();

  private final boolean CONTROL_HOVER = true;
  private Node HOVERING_RECTANGLE = null;
  private int HOVERING_RECTANGLE_ID = -1;
  private Node SELECTED_RECTANGLE = null;
  private int SELECTED_RECTANGLE_ID = -1;

  private Runnable hovering;
  private Runnable selected;

  public TiledGraphs(Set<Graph> graphs, JFrame frame) {

    this.frame = frame;
    this.graphs = graphs;
    clustersAcross = (frame.getWidth() - 2 * defaultBorder) / (clusterWidth + 2 * defaultGutter);
    clustersAcross = clustersAcross > graphs.size() ? graphs.size() : clustersAcross;
    clustersAlong = graphs.size() / clustersAcross + (graphs.size() % clustersAcross > 0 ? 1 : 0);
    height = 2 * defaultBorder + clustersAlong * (clusterHeight + 2 * defaultGutter);
  }

  public void draw() {

    // Create the SVG document
    DOMImplementation impl = SVGDOMImplementation.getDOMImplementation();
    String svgNS = SVGDOMImplementation.SVG_NAMESPACE_URI;
    svg = (SVGDocument) impl.createDocument(svgNS, "svg", null);
    SVGGeneratorContext ctx = SVGGeneratorContext.createDefault(svg);
    ctx.setComment("Generated by Etomica Cluster Viewer using Apache Batik.");
    ctx.setEmbeddedFontsOn(true);
    Element root = svg.getDocumentElement();
    root.setAttributeNS(null, "style", "fill-opacity:1;stroke-width:1.1;stroke-opacity:1");
    root.setAttributeNS(null, "width", String.valueOf(frame.getWidth()));
    root.setAttributeNS(null, "height", String.valueOf(height));

    int col = 0;
    int row = 0;
    for (Graph g : graphs) {
      int hzGutter = (col == 0 ? defaultGutter : 2 * col * defaultGutter);
      int vtGutter = (row == 0 ? defaultGutter : 2 * row * defaultGutter);
      drawCluster(g, defaultBorder + hzGutter + col * clusterWidth, defaultBorder + vtGutter + row
          * clusterHeight);
      col++;
      if (col % clustersAcross == 0) {
        col = 0;
        row++;
      }
    }

    SVGGraphics2D g2 = new SVGGraphics2D(svg);
    g2.getRoot(svg.getDocumentElement());
    canvas = new JSVGCanvas();
    canvas.setDocumentState(JSVGComponent.ALWAYS_DYNAMIC);
    JSVGScrollPane spane = new JSVGScrollPane(canvas);
    SVGContextMenu menu = new SVGContextMenu(spane);
    canvas.setSVGDocument(svg);
    canvas.addMouseMotionListener(getMouseMotionListener(menu));
    canvas.addMouseListener(getMouseClickedListener(menu));
    // create the mouse listeners for the canvas
    hovering = new HoveringRectangle();
    selected = new SelectedRectangle();
    // add the pane to the frame
    frame.setContentPane(spane);
  }

  /**
   * This method translates a point within the SVG canvas into a tile in the array of
   * tiles which are drawn on the canvas. If the point does not correspond to a tile, the
   * method returns the length of the array of tiles, otherwise it returns the tile to
   * which the point belongs.
   */
  public int getTile(Point p) {

    int col = (p.x - defaultBorder) / (clusterWidth + 2 * defaultGutter);
    int row = (p.y - defaultBorder) / (clusterHeight + 2 * defaultGutter);
    if ((row >= clustersAlong) || (col >= clustersAcross)) {
      return tiles.size();
    }
    return col + row * clustersAcross;
  }

  private Node drawCluster(Graph graph, int dX, int dY) {

    int r = nodeRadius;
    float dr = nodeRadius * 0.2f;
    int R = graphRadius;
    int size = graph.nodeCount();
    double[] x = new double[size];
    double[] y = new double[size];
    double initialAngle = Math.PI / 2;
    double minX = -1, minY = -1, maxX = -1, maxY = -1;
    double angle = 2.0 * Math.PI / size;
    Shape node = new Ellipse2D.Double(0, 0, r, r);
    Shape nodei = new Ellipse2D.Double(0, 0, r - dr, r - dr);
    // create 2D graphics compatible with the SVGCanvas
    SVGGraphics2D g = new SVGGraphics2D(svg);
    // add hints to improve the quality of the images
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    g.translate(defaultBorder, defaultBorder);
    // compute node centers, as well as the minimum and maximum X and Y
    // positions of the cluster nodes; with this information, we define
    // the bounding rectangles around each cluster
    for (int i = 0; i < size; i++) {
      x[i] = (R - r) * Math.cos(initialAngle + i * angle) + (R - r + dX);
      y[i] = (R - r) * Math.sin(initialAngle + i * angle) + (R - r + dY);
      if (minX == -1) {
        minX = x[i];
        maxX = x[i];
        minY = y[i];
        maxY = y[i];
      }
      if (minX > x[i]) {
        minX = x[i];
      }
      if (maxX < x[i]) {
        maxX = x[i];
      }
      if (minY > y[i]) {
        minY = y[i];
      }
      if (maxY < y[i]) {
        maxY = y[i];
      }
    }
    // compute the bounding rectangle of this cluster; gutter spaces are added
    // to top, bottom, left, and right so that the clusters are not too tightly
    // packed on the canvas
    Rectangle2D rect = new Rectangle2D.Double(defaultBorder + minX - defaultGutter, defaultBorder + minY
        - defaultGutter, maxX - minX + r + 2 * defaultGutter, maxY - minY + r + 2 * defaultGutter);
    // the bounding rectangle just computed is a "tile" on the SVGCanvas
    tiles.add(rect);
    // // all clusters have the same dimensions, so if this is the first cluster
    // // we computed, define the default cluster width and height
    // if (clusterHeight < 0) {
    // setDimensions((int) Math.round(rect.getHeight()), (int)
    // Math.round(rect.getWidth()));
    // }
    // edges are the bottom layer, so we draw them first
    for (Edge e : graph.edges()) {
      byte i = graph.getFromNode(e.getId());
      byte j = graph.getToNode(e.getId());
      Point2D pi = new Point2D.Double(x[i] + r / 2, y[i] + r / 2);
      Point2D pj = new Point2D.Double(x[j] + r / 2, y[j] + r / 2);
      g.setPaint(COLORS[COLOR_CODES.indexOf(graph.getEdge(i, j).getColor())]);
      g.draw(new Line2D.Double(pi, pj));
    }
    // nodes are in the top layer, so we draw them last
    for (byte i = 0; i < size; i++) {
      g.translate(x[i], y[i]);
      // a root node is hollow and has a thick stroke with the node color
      if (graph.getNode(i).getType() == TYPE_NODE_ROOT) {
        g.setPaint(COLORS[COLOR_CODES.indexOf(graph.getNode(i).getColor())]);
        g.fill(node);
        g.translate(dr / 2, dr / 2);
        g.setPaint(Color.WHITE);
        g.fill(nodei);
        g.translate(-dr / 2, -dr / 2);
      }
      // a field node is filled with the node color and has a thin black stroke
      else {
        g.setPaint(Color.BLACK);
        g.fill(node);
        g.translate(dr / 2, dr / 2);
        g.setPaint(COLORS[COLOR_CODES.indexOf(graph.getNode(i).getColor())]);
        g.fill(nodei);
        g.translate(-dr / 2, -dr / 2);
      }
      g.translate(-x[i], -y[i]);
    }
    // update the document such that this new cluster is added as a node
    // below the root; this way all clusters are independent objects on
    // the SVG document
    Element root = svg.getDocumentElement();
    Node child = g.getTopLevelGroup().getFirstChild();
    return root.appendChild(child);
  }

  private String getExtension(String fileName) {

    String ext = null;
    String s = fileName;
    int i = s.lastIndexOf('.');
    if (i > 0 && i < s.length() - 1) {
      ext = s.substring(i).toLowerCase();
    }
    return ext;
  }

  private String getMimeType(String fileName) {

    String ext = getExtension(fileName);
    if (ext.equals(DestinationType.JPEG_EXTENSION)) {
      return DestinationType.JPEG_STR;
    }
    if (ext.equals(DestinationType.JPEG_EXTENSION)) {
      return DestinationType.JPEG_STR;
    }
    if (ext.equals(DestinationType.PDF_EXTENSION)) {
      return DestinationType.PDF_STR;
    }
    if (ext.equals(DestinationType.PNG_EXTENSION)) {
      return DestinationType.PNG_STR;
    }
    if (ext.equals(DestinationType.TIFF_EXTENSION)) {
      return DestinationType.TIFF_STR;
    }
    return null;
  }

  public void imageOut(String fileName) {

    File f = null;
    try {
      f = File.createTempFile("tmp_", "svg");
      FileOutputStream fs = new FileOutputStream(f);
      streamOut(fs);
      fs.flush();
      fs.close();
      String[] options = new String[13];
      // destination
      options[0] = Main.CL_OPTION_OUTPUT;
      options[1] = fileName;
      // destination type
      options[2] = Main.CL_OPTION_MIME_TYPE;
      options[3] = getMimeType(fileName);
      // quality (for JPEG)
      options[4] = Main.CL_OPTION_QUALITY;
      options[5] = "0.8";
      // resolution
      options[6] = Main.CL_OPTION_DPI;
      options[7] = "300";
      // resolution
      options[8] = Main.CL_OPTION_WIDTH;
      options[9] = "1024";
      // resolution
      options[10] = Main.CL_OPTION_BACKGROUND_COLOR;
      options[11] = "255.255.255.255";
      // input file
      options[12] = f.getAbsolutePath();
      // convert
      Main c = new Main(options);
      c.execute();
      // remove temporary file
      f.delete();
    }
    catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void streamOut(OutputStream out) {

    // Stream out SVG to the standard output using UTF-8 encoding.
    try {
      TranscoderInput input = new TranscoderInput(svg);
      TranscoderOutput output = new TranscoderOutput(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
      Transcoder t = new SVGTranscoder();
      t.transcode(input, output);
    }
    catch (TranscoderException e) {
      e.printStackTrace();
    }
    catch (UnsupportedEncodingException uee) {
      uee.printStackTrace();
    }
  }

  public void prepareSave() {

    HOVERING_RECTANGLE_ID = -1;
    SELECTED_RECTANGLE_ID = -1;
    final Runnable selected = new SelectedRectangle();
    UpdateManager um = canvas.getUpdateManager();
    try {
      um.getUpdateRunnableQueue().invokeAndWait(selected);
    }
    catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  private MouseListener getMouseClickedListener(final SVGContextMenu menu) {

    return new MouseAdapter() {

      @Override
      public void mouseClicked(MouseEvent e) {

        int newSelected = getTile(e.getPoint());
        if (newSelected >= tiles.size()) {
          menu.setVisible(false);
          return;
        }
        Point p = new Point(e.getPoint());
        SwingUtilities.convertPointToScreen(p, canvas);
        if (menu.isVisible()) {
          if (e.getButton() == MouseEvent.BUTTON3) {
            menu.setLocation(p);
            return;
          }
          else {
            menu.setVisible(false);
          }
        }
        if (e.getButton() == MouseEvent.BUTTON3) {
          menu.setLocation(p);
          menu.setVisible(true);
        }
        else if (e.getButton() == MouseEvent.BUTTON1) {
          if (SELECTED_RECTANGLE_ID == newSelected) {
            SELECTED_RECTANGLE_ID = -1;
          }
          else {
            SELECTED_RECTANGLE_ID = newSelected;
          }
          HOVERING_RECTANGLE_ID = -1;
          canvas.getUpdateManager().getUpdateRunnableQueue().invokeLater(selected);
        }
      }
    };
  }

  private MouseMotionListener getMouseMotionListener(final SVGContextMenu menu) {

    return new MouseMotionListener() {

      public void mouseMoved(MouseEvent e) {

        if (CONTROL_HOVER && (e.getButton() == MouseEvent.NOBUTTON)) {
          menu.setVisible(false);
          int newHover = getTile(e.getPoint());
          if (newHover >= tiles.size()) {
            newHover = -1;
          }
          if (SELECTED_RECTANGLE_ID == newHover) {
            newHover = -1;
          }
          if (newHover != HOVERING_RECTANGLE_ID) {
            if (newHover == -1) {
              HOVERING_RECTANGLE_ID = -1;
            }
            else {
              HOVERING_RECTANGLE_ID = newHover;
            }
            UpdateManager um = canvas.getUpdateManager();
            if (um != null) {
              um.getUpdateRunnableQueue().invokeLater(hovering);
            }
          }
        }
      }

      public void mouseDragged(MouseEvent e) {

        // no-op
      }
    };
  }

  /**
   * The classes below are Runnable implementations of painting routines for the
   * SVGCanvas. The SVGCanvas canvas follows the Swing approach to painting in that all
   * painting operations must happen on the same thread. Therefore, these runnable objects
   * are queued for execution through the SVGCanvas UpdateManager Queue, which schedules
   * them for execution on the Swing thread. All styles for painting and drawing are
   * defined as constants at the SVGDraw class.
   *
   * @author Demian Lessa
   */
  abstract class PaintRunnable implements Runnable {

    protected Map<Integer, Node> rectangles = new HashMap<Integer, Node>();
    protected Color color;
    protected Stroke stroke;

    PaintRunnable(Stroke stroke, Color color) {

      this.color = color;
      this.stroke = stroke;
    }

    protected void clearSelection() {

      if (SELECTED_RECTANGLE != null) {
        Element root = svg.getDocumentElement();
        root.removeChild(SELECTED_RECTANGLE);
        SELECTED_RECTANGLE = null;
      }
    }

    protected void clearHovering() {

      if (HOVERING_RECTANGLE != null) {
        Element root = svg.getDocumentElement();
        root.removeChild(HOVERING_RECTANGLE);
        HOVERING_RECTANGLE = null;
      }
    }

    protected Node drawRectangle(int i) {

      if (!rectangles.containsKey(i)) {
        // draw the cluster on an SVG canvas
        SVGGraphics2D g = new SVGGraphics2D(svg);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g.setStroke(stroke);
        g.setPaint(color);
        g.draw(tiles.get(i));
        Node child = g.getTopLevelGroup().getFirstChild();
        rectangles.put(i, child);
      }
      Element root = svg.getDocumentElement();
      return root.appendChild(rectangles.get(i));
    }
  }

  /**
   * The purpose of this class is to paint a selected rectangle around a single cluster,
   * clearing up any other existing selected rectangles.
   *
   * @author Demian Lessa
   */
  class SelectedRectangle extends PaintRunnable {

    SelectedRectangle() {

      super(SELECTED_STROKE, SELECTED_COLOR);
    }

    public void run() {

      clearHovering();
      clearSelection();
      if (SELECTED_RECTANGLE_ID != -1) {
        SELECTED_RECTANGLE = drawRectangle(SELECTED_RECTANGLE_ID);
      }
    }
  }

  /**
   * The purpose of this class is to paint a hovering rectangle around a single cluster,
   * clearing up any other existing hovering rectangles. No hovering rectangle is painted
   * if the rectangle under the mouse is selected.
   *
   * @author Demian Lessa
   */
  class HoveringRectangle extends PaintRunnable {

    HoveringRectangle() {

      super(HOVERING_STROKE, HOVERING_COLOR);
    }

    public void run() {

      clearHovering();
      if (HOVERING_RECTANGLE_ID != -1) {
        HOVERING_RECTANGLE = drawRectangle(HOVERING_RECTANGLE_ID);
      }
    }
  }

  class SVGContextMenu extends JPopupMenu {

    private static final long serialVersionUID = -5605994099188052122L;
    public static final float EXPORT_WIDTH = 1024f;
    private Component owner;

    public SVGContextMenu(Component parent) {

      super();
      this.owner = parent;
      JMenuItem menuSaveAs = new JMenuItem("Save as...");
      add(menuSaveAs);
      MouseListener popupListener = new SaveAsListener();
      menuSaveAs.addMouseListener(popupListener);
    }

    /**
     * This listener exports the SVGCanvas to an appropriate file based on the selection
     * of destination file name defined by the user.
     *
     * @author Demian Lessa
     */
    class SaveAsListener extends MouseAdapter {

      private void save(File file) throws Exception {

        String ext = SVGFileFilter.getExtension(file);
        if (ext == null) {
          return;
        }
        if (ext.equals(SVGFileFilter.EXT_svg)) {
          writeOut(file, new SVGTranscoder());
        }
        else if (ext.equals(SVGFileFilter.EXT_gif)) {
          File f = File.createTempFile("tmp_", ".png");
          imageOut(f.getAbsolutePath());
          // read the temporary PNG file into an image
          BufferedImage image = ImageIO.read(f);
          // write the image to disk
          ImageIO.write(image, ext, file);
          f.delete();
        }
        else {
          imageOut(file.getAbsolutePath());
        }
      }

      // for SVG only
      private void writeOut(File file, Transcoder t) throws Exception {

        // Set the transcoder input and output.
        TranscoderInput input = new TranscoderInput(svg);
        OutputStream ostream = new FileOutputStream(file);
        Writer w;
        if (t instanceof SVGTranscoder) {
          w = new OutputStreamWriter(ostream, "UTF-8");
        }
        else {
          w = new OutputStreamWriter(ostream);
        }
        TranscoderOutput output = new TranscoderOutput(w);
        // Transcode
        t.transcode(input, output);
        ostream.flush();
        ostream.close();
      }

      // make sure that after selecting the "save as" option, we clear all
      // adornments on the SVGCanvas- namely, the selection and hover rectangles
      public void mouseClicked(MouseEvent e) {

        canvas.setEnabled(false);
        prepareSave();
        setVisible(false);
        JFileChooser fc = new SVGFileChooser();
        if (fc.showSaveDialog(owner) == JFileChooser.APPROVE_OPTION) {
          File f = fc.getSelectedFile().getAbsoluteFile();
          if (f.exists()) {
            int actionDialog = JOptionPane.showConfirmDialog(owner, "Replace existing file?");
            if (actionDialog != JOptionPane.YES_OPTION) {
              return;
            }
          }
          try {
            save(fc.getSelectedFile().getAbsoluteFile());
            // System.out.println("Saved file: " +
            // fc.getSelectedFile().getAbsoluteFile());
          }
          catch (Exception e1) {
            // cowardly ignore
            e1.printStackTrace();
          }
        }
        canvas.setEnabled(true);
      }
    }
  }

  /**
   * Filter with all supported destination formats for exporting the image in the
   * SVGCanvas.
   *
   * @author Demian Lessa
   */
  static class SVGFileFilter extends javax.swing.filechooser.FileFilter {

    public final static String EXT_gif = "gif";
    public final static String EXT_jpg = "jpg";
    public final static String EXT_pdf = "pdf";
    public final static String EXT_png = "png";
    public final static String EXT_svg = "svg";
    public final static String EXT_tif = "tif";

    private final static String DESC_gif = "GIF bitmap (*.gif)";
    private final static String DESC_jpg = "JPEG bitmap (*.jpeg)";
    private final static String DESC_pdf = "PDF document (*.pdf)";
    private final static String DESC_png = "PNG bitmap (*.png)";
    private final static String DESC_svg = "SVG vector graphic (*.svg)";
    private final static String DESC_tif = "TIFF bitmap (*.tif)";

    private final static SVGFileFilter FILTER_GIF = new SVGFileFilter(EXT_gif, DESC_gif);
    private final static SVGFileFilter FILTER_JPG = new SVGFileFilter(EXT_jpg, DESC_jpg);
    private final static SVGFileFilter FILTER_PDF = new SVGFileFilter(EXT_pdf, DESC_pdf);
    private final static SVGFileFilter FILTER_PNG = new SVGFileFilter(EXT_png, DESC_png);
    private final static SVGFileFilter FILTER_SVG = new SVGFileFilter(EXT_svg, DESC_svg);
    private final static SVGFileFilter FILTER_TIFF = new SVGFileFilter(EXT_tif, DESC_tif);

    private String extension;
    private String description;

    public SVGFileFilter(String ext, String desc) {

      super();
      extension = ext;
      description = desc;
    }

    public static String getExtension(File f) {

      String ext = null;
      String s = f.getName();
      int i = s.lastIndexOf('.');
      if (i > 0 && i < s.length() - 1) {
        ext = s.substring(i + 1).toLowerCase();
      }
      return ext;
    }

    @Override
    public boolean accept(File f) {

      if (f.isDirectory()) {
        return true;
      }
      String ext = getExtension(f);
      return (ext != null) && (ext.equals(extension));
    }

    @Override
    public String getDescription() {

      return description;
    }

    public String getExtension() {

      return extension;
    }
  }

  /**
   * Customized JFileChooser aware of the SVGCanvas export filters.
   *
   * @author Demian Lessa
   */
  static class SVGFileChooser extends JFileChooser {

    private static final long serialVersionUID = -9020881522405108590L;

    public SVGFileChooser() {

      super();
      setDialogTitle("Export Cluster Diagrams");
      setAcceptAllFileFilterUsed(false);
      addChoosableFileFilter(SVGFileFilter.FILTER_GIF);
      addChoosableFileFilter(SVGFileFilter.FILTER_JPG);
      addChoosableFileFilter(SVGFileFilter.FILTER_PDF);
      addChoosableFileFilter(SVGFileFilter.FILTER_PNG);
      addChoosableFileFilter(SVGFileFilter.FILTER_SVG);
      addChoosableFileFilter(SVGFileFilter.FILTER_TIFF);
      setFileFilter(SVGFileFilter.FILTER_SVG);
    }

    @Override
    public int showSaveDialog(Component component) throws HeadlessException {

      int result = super.showSaveDialog(component);
      if (result == JFileChooser.APPROVE_OPTION) {
        File sf = getSelectedFile();
        String ext = SVGFileFilter.getExtension(sf);
        String fext = ((SVGFileFilter) getFileFilter()).getExtension();
        if ((ext == null) || (!ext.equals(fext))) {
          File nsf = new File(sf.getAbsolutePath() + "." + fext);
          setSelectedFile(nsf);
        }
      }
      return result;
    }
  }
}