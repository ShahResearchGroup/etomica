package simulate;
import java.io.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;

/**
 * The applies method of error calculation as described by Kolafa.
 * A Class which calculates the average and error of a sequence of correlated values,
 * such as those generated by a M.<!-- -->C.<!-- --> simulation.
 *
 * @author Carl Barnes
 * @version %I%, %G%
 */
public class ErrorBlock {
   transient private int blockcount = 0;   //count number of blocks updated.
   private transient int BlockSaveBit = 0; //test to see if this is the first block
   private transient int cyclecount = 0;  //cycles per block
   private transient double block0 = 0;   //1st block of the run.
   private transient double block1 = 0;   //running sum of variable.
   private transient double block2 = 0;    //value of previous block.
   private transient double subaverage0 = 0;  //running sum of block1 divided by # of configurations.
   private transient double subaverage1 = 0;     //running sum of (block1/cycle_count)^2.
   private transient double subaverage2 = 0;     //running sum of (block1*block2)/cyclecount^2.

   //for method error
   private transient double e_c1;
   private transient double e_c0;
   private transient double e_c;
   private transient double e_factor;
   private transient double argument;
   private transient double bc0;
   private transient double bc1;
   private transient double bc2;

  /**
   *Class constructor
   */
  public ErrorBlock() {;}

  /**
   * Calculates the running average, same method as for the standard
   * average.
   *
   * @return The running average.
   * @see simulate.ErrorStd#average()
   */
  public double average(){return subaverage0/(double)blockcount;}

  /**
   * Calculates the error in the running average based on information
   * from the current and previous "blocks".
   *
   * @return The error in the running average.
   */
  public double error() {
    //correlation
    bc0 = 1.0/(double)blockcount;
    bc1 = 1.0/(double)(blockcount - 1.0);
    bc2 = 1.0/(double)(blockcount - 2.0);

    e_c0 = bc1*(subaverage1 - subaverage0*subaverage0*bc0);
    e_c1 = bc2*(subaverage2 - (subaverage0 - block0)*(subaverage0 - block2)*bc1);
    e_c = e_c1/e_c0;
    e_factor = (1.0+3.0*e_c)/((1.0+2.0*e_c)*(1.0-e_c));
    //argument = bc0*e_c0*e_factor;
    return Math.sqrt(bc0*e_c0*e_factor);
  }

  /**
   * Adds an <code>integer</code> to a running sum in the current "block".
   * Increments a counter.  Sends a message if the values of counter exceeds
   * the largest value for a signed integer, at which point the counter loops
   * to a negative value.
   *
   * @parm data  The <code>integer</code> value to be added to the running sum.
   * @see #update()
   */
  public void sum(int data) {
    block1 += (double)data;
    cyclecount++;
  }

  /**
   * Adds a <code>double</code> to a running sum in the current "block".
   * Increments a counter.  Sends a message if the values of counter exceeds
   * the largest value for a signed integer, at which point the counter loops
   * to a negative value.
   *
   * @parm data  The <code>double</code> value to be added to the running sum.
   * @see #update()
   */
  public void sum(double data) {
    block1 += data;
    cyclecount++;
  }

  /**
   * Adds the sum of values in the current block to the sum of the previous "blocks".
   * Also applies algorithms to other internal variables which are used in
   * calulating the error.
   * In the method of Kolafa, the sequential values are broken down into "blocks"
   * of values, each block containing the same number of values (N).  This method
   * must be called after calling <code>sum</code> N times, in other words at the
   * end of each block all of which are the same length.
   *
   * @see #sum(int)
   */
  public void update() {
    blockcount++;
    subaverage0 += block1/(double)cyclecount;
    subaverage1 += block1*block1/((double)(cyclecount*cyclecount));
    subaverage2 += block2*block1/(double)cyclecount;

    if(subaverage1<0) {
      System.out.println("subaverage < 0 in method BlErr.error\n");
      //cout.flush();
      //ofstream fout("BlErr_ERROR",ios::app);
      //fout<<"very likely the the sum has wrapped to negative numbers in class BlErr, method update\n";
      //fout.close();
      //exit(1);
    }

    //set previous block = current block, zero current block and cyclecount

    block2 = block1/(double)cyclecount;
    block1 = 0.0;
    cyclecount = 0;
    //save first block to block0

    if(BlockSaveBit == 0) {
      block0 = block2;
      subaverage2 = 0;
      BlockSaveBit = 1;
    }
  }

  /**
   * Sets all the variables to zero (public and private).  A convenience
   * method to allow an instance of this class to be reused for a new set
   * of data.
   */
  public void zero() {
    blockcount = 0;
    BlockSaveBit = 0;
    cyclecount = 0;
    block0 = 0;
    block1 = 0;
    block2 = 0;
    subaverage0 = 0;
    subaverage1 = 0;
    subaverage2 = 0;
  }
}

