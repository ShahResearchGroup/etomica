package etomica.nbr.cell;
import etomica.Atom;
import etomica.AtomIterator;
import etomica.AtomIteratorAtomDependent;
import etomica.AtomIteratorList;
import etomica.AtomIteratorListSimple;
import etomica.AtomIteratorMolecule;
import etomica.AtomLinker;
import etomica.AtomList;
import etomica.AtomReservoir;
import etomica.AtomSequencer;
import etomica.AtomTreeNodeGroup;
import etomica.Controller;
import etomica.Default;
import etomica.Integrator;
import etomica.IntegratorHard;
import etomica.IntegratorMC;
import etomica.IteratorDirective;
import etomica.IteratorFactory;
import etomica.MCMoveAtom;
import etomica.Mediator;
import etomica.P2HardSphere;
import etomica.P2SquareWell;
import etomica.Phase;
import etomica.PhaseEvent;
import etomica.PhaseListener;
import etomica.Potential;
import etomica.Potential2;
import etomica.Simulation;
import etomica.Space;
import etomica.Space2D;
import etomica.Species;
import etomica.SpeciesSpheresMono;
import etomica.utility.java2.HashMap;

import etomica.AtomLinker.Tab;
import etomica.AtomReservoir.ReservoirAtomTreeNode;
import etomica.AtomSequencer.Factory;
import etomica.IteratorDirective.Direction;
import etomica.Mediator.PhaseNull;
import etomica.Space.Vector;
import etomica.action.AtomAction;
import etomica.action.AtomActionAdapter;
import etomica.action.AtomsetAction;
import etomica.lattice.*;
import etomica.math.geometry.Polyhedron;
import etomica.utility.java2.Iterator;

/**
 * Iterator factory that uses a cell-based neighbor list.  Constructed
 * and functions as follows.<br>
 * Factory is attached to a simulation by invoking the setIteratorFactory method
 * (in Simulation) with an instance of this factory as an argument.
 * Mediator is placed in simulation when this factory is constructed.  This
 * mediator causes a cell lattice to be attached to each phase.
 * Atom factories decide whether each atom it constructs is given a simple
 * sequencer or a neighbor sequencer; this specification is made by passing
 * to the atom's constructor the corresponding sequencer factory given
 * by the make*SequencerFactory methods of this iterator factory.  Usually
 * neighbor sequencers are given to molecules, and simple sequencers are
 * used for the atoms and groups they comprise.  In large molecules (e.g. polymers)
 * it may be the subgroups of each molecule that are organized into the cells.<br>
 *
 * Atom is first assigned to its cell when it is constructed in the AtomFactory.makeAtom
 * method.  Its cell assignment is updated every time a translate method is
 * called in its coordinate class (translateTo, translateBy, etc. all perform a call
 * to moveNotify method of the atom's sequencer after doing the move).  The assignment
 * is also updated whenever the setParent method of the node is called (sequencer
 * is informed via its setParentNotify method) or if the [to be implemented] reset
 * method of the iterator factory is called (either directly, or by the registered observer
 * of the lattice when it is informed of a change in the lattice constant or dimensions).
 * The childList of the parent of cell-listed atoms organizes the atoms via their
 * sequencers, which are subclasses of AtomLinker.  The childList contains Tabs that 
 * demark the set of sequencers contained in a given cell.  As an atom moves from one
 * cell to another, it is shuffled in the childList into the segment corresponding
 * to its new cell.  Each cell references separately a fixed set of neighbor cells, and atoms
 * within those cells are accessed for each neighbor cell through the tab it has
 * in the childList.  (actually, the NeighborSequencer contains an "inner"
 * atomlinker that is used to maintain the cell structure; the "main" sequence
 * generally does not change and doesn't keep the cell ordering.  It was found
 * necessary to use two sequences for the times when looping through the atoms
 * and translating each in space; each translation potentially modifies the
 * cell-list sequence, so to get through the list properly the fixed-sequence
 * option is needed).  The neighbor and sequential iterators generated by this
 * factory adhere to the cell-list sequencing; list iterators generated directly
 * (externally to this factory) will loop through the fixed (not cell-ordered)
 * sequence when given the parent's childList as its basis.
 *
 * @author David Kofke
 * 02.02.05
 * 
 */

/* History
 * 03/19/03 (DAK) fixed makeCellLattice method to compare r2 to square of
 * neighbor range
 * 08/10/03 (DAK) made fields protected so can be seen by subclasses
 * 08/12/03 (DAK) modified as indicated in comments in code
 * 
 */
public class IteratorFactoryCell implements IteratorFactory {
    
    protected Primitive primitive;
    protected Simulation simulation;
    protected int[] dimensions;
    protected BravaisLattice[] deployedLattices = new BravaisLattice[0];
    protected double neighborRange;
    
    /**
     * Constructs a new iterator factory for the given simulation, using
     * cubic cells for the neighbor listing.  Does not automatically
     * register the factory with the simulation; this must be done
     * separately using the simulation's setIteratorFactory method.
     * For Simulation sim, at typical call is
     * sim.setIteratorFactory(new IteratorFactoryCell(sim));
     */
    public IteratorFactoryCell(Simulation sim) {
        this(sim, new PrimitiveCubic(sim.space), 10);
    }
    
    /**
     *  
     * @param sim  The simulation in which this factory is being used
     * @param nCells the number of cell in each dimension; total number of cells
     * is then nCells^D.
     */
    public IteratorFactoryCell(Simulation sim, int nCells) {
    	this(sim, new PrimitiveCubic(sim.space), nCells);
    }
    
    /**
     * Constructs a new iterator factory for the given simulation, using
     * cells based on the given primitive.  Does not automatically
     * register the factory with the simulation; this must be done
     * separately using the simulation's setIteratorFactory method.
     *
     * @param sim          The simulation in which this factory is being used
     * @param primitive    The primitive class that defines the type of unit
     * cell used to construct the neighbor-cell lattice
     * @param nCells the number of cell in each dimension; total number of cells is then nCells^D.
     */
    public IteratorFactoryCell(Simulation sim, Primitive primitive, int nCells) {
        this.simulation = sim;
        this.primitive = primitive;
        neighborRange = Default.ATOM_SIZE;
        dimensions = new int[sim.space.D()];
        for(int i=0; i<sim.space.D(); i++) dimensions[i] = nCells;
        
        //Add mediator that places a cell lattice in each phase.
        sim.mediator().addMediatorPair( new Mediator.PhaseNull(sim.mediator()) {
            public void add(Phase phase) {makeCellLattice(phase);}
        });        
    }
    
    /**
     * Constructs the cell lattice used to organize all cell-listed atoms
     * in the given phase.  Each new lattice is set up with its own instance
     * of the primitive, formed by copying the instance associated with this factory.  
     * Note that the phase does not contain any reference
     * to the lattice.  Its association with the phase is made through the 
     * deployedLattices array kept by this iterator factory class, and by 
     * the reference in each neighbor sequencer to the cell containing its atom.
     */
    public BravaisLattice makeCellLattice(final Phase phase) {
        if(phase.simulation() != simulation) throw new IllegalArgumentException("Attempt to apply iterator factory to a phase from a different simulation"); 
        //make the unit cell factory and set it to produce cells of the appropriate size
        final Primitive primitiveCopy = primitive.copy();//each new lattice works with its own primitive
///        AtomFactory cellFactory = primitiveCopy.unitCellFactory();
        Space.Vector primitiveSize = simulation.space.makeVector();
        primitiveSize.E(phase.boundary().dimensions());
        primitiveSize.DE(Space.makeVector(dimensions));
        primitiveCopy.setSize(primitiveSize.toArray());
        //construct the lattice
///        AtomFactory latticeFactory = new BravaisLattice.Factory(simulation, cellFactory, dimensions, primitiveCopy);
///        final BravaisLattice lattice = (BravaisLattice)latticeFactory.makeAtom();
        final BravaisLattice lattice = BravaisLattice.makeUnitCellLattice(simulation.space, dimensions, primitiveCopy);
        lattice.shiftFirstToOrigin();
        primitiveCopy.setLattice(null);
        
        //set up the neighbor lists for each cell in the lattice
        etomica.lattice.NeighborManager.Criterion neighborCriterion = new etomica.lattice.NeighborManager.Criterion() {
            public boolean areNeighbors(Site s1, Site s2) {
                return ((Polyhedron)s1).r2NearestVertex((Polyhedron)s2, phase.boundary()) < neighborRange*neighborRange;//03/19/03 corrected to make neighborrange squared
            }
        };
        lattice.setupNeighbors(neighborCriterion);
        
        //instantiate the hashmap that will hold the index Integers that
        //are keyed to the the parentGroup of cell-listed set of children
        lattice.agents = new Object[1];
        lattice.agents[0] = new HashMap();
        
        //resize and update array that enables lookup of the lattice in any given phase
        int latticeCountOld = deployedLattices.length;
        if(phase.index >= latticeCountOld) {
            BravaisLattice[] newArray = new BravaisLattice[phase.index+1];
            for(int i=0; i<latticeCountOld; i++) newArray[i] = deployedLattices[i];
            deployedLattices = newArray;
        }
        deployedLattices[phase.index] = lattice;
        
        //add listener to notify all sequencers of any lattice events (resizing of lattice, for example)
        lattice.eventManager.addListener(new LatticeListener() {
            public void actionPerformed(LatticeEvent evt) {
                if(evt.type() == LatticeEvent.REBUILD || evt.type() == LatticeEvent.ALL_SITE) {
                    Phase p = getPhase((BravaisLattice)evt.lattice());
                    if(p == null) return;
                    AtomIteratorMolecule iterator = new AtomIteratorMolecule(p);
					iterator.reset();
                    while(iterator.hasNext()) ((CellSequencer)iterator.nextAtom().seq).latticeChangeNotify();
                }//end if
            }
        });
        
        //add listener to phase to update the size and placement of the lattice
        //cells if the phase undergoes an inflation of its boundary.
        //An inflation event should not, however, cause the molecules to be reassigned
        //to their lattice cells, since the atom positions and the cells scale proportionately
        //Atoms in molecules may be reassigned, if they are the focus of neighbor listing (which is not usually the case)
        phase.boundaryEventManager.addListener(new PhaseListener() {
            final AtomIteratorListSimple cellIterator = new AtomIteratorListSimple();
            double[] newSize;
            public void actionPerformed(PhaseEvent evt) {
                if(!evt.type().equals(PhaseEvent.BOUNDARY_INFLATE)) return;
                    //we expect that primitive.lattice() == null, so change of size doesn't cause replacement of atoms in cells
                if(evt.isotropic) {
                    primitiveCopy.scaleSize(evt.isoScale);
                    cellIterator.setList(lattice.siteList());
                    cellIterator.reset();
                    while(cellIterator.hasNext()) {
                        cellIterator.nextAtom().coord.inflate(evt.isoScale);
                    }
                } else {//anisotropic inflation
                    if(primitiveCopy instanceof PrimitiveCubic) throw new RuntimeException("Cannot handle anisotropic inflate with cubic primitive used in IteratorFactoryCell");
                    newSize = ((PrimitiveOrthorhombic)primitiveCopy).getSize();
                    for(int i=0; i<newSize.length; i++) newSize[i] *= evt.anisoScale.x(i);
                    primitiveCopy.setSize(newSize);
                    cellIterator.setList(lattice.siteList());
                    cellIterator.reset();
                    while(cellIterator.hasNext()) {
                        cellIterator.nextAtom().coord.inflate(evt.anisoScale);
                    }
                }
            }//end actionPerformed
        });
        return lattice;
    }//end of makeCellLattice method
    
    /**
     * Returns the cell lattice corresponding to the given phase.
     */
    public BravaisLattice getLattice(Phase phase) {
        if(phase == null) return null;
        else return deployedLattices[phase.index];
    }
    
    /**
     * Returns the phase corresponding to the given cell lattice.
     */
    public Phase getPhase(BravaisLattice lattice) {
        if(lattice == null) return null;
        //check all phases that have been added to the simulation
        for(Iterator ip=simulation.getPhaseList().iterator(); ip.hasNext(); ) {
            Phase phase = (Phase)ip.next();
            if(getLattice(phase) == lattice) return phase;
        }
        return null;//no phase corresponding to given lattice found in simulation
    }
    
    /**
     * Sets the maximum range of interaction for which the cells must keep neighbors.
     * Updates the neighbor lists of all previous and future cell lattices consistent
     * with the new value.
     */
    public void setNeighborRange(double r) {
        neighborRange = r;
        final double rangeSquared = r*r;
        for(int i=0; i<deployedLattices.length; i++) {
            final Phase phase = getPhase(deployedLattices[i]);
            etomica.lattice.NeighborManager.Criterion neighborCriterion = new etomica.lattice.NeighborManager.Criterion() {
                public boolean areNeighbors(Site s1, Site s2) {
                    return ((Polyhedron)s1).r2NearestVertex((Polyhedron)s2, phase.boundary()) < rangeSquared;
                }
            };
            deployedLattices[i].setupNeighbors(neighborCriterion);
        }
    }
    /**
     * Accessor method for the maximum range of interaction for which cells must keep neighbors.
     */
    public double getNeighborRange() {return neighborRange;}


    public AtomIterator makeGroupIteratorSequential() {
        return new SequentialIterator(this);
    }
        
    public AtomIteratorAtomDependent makeIntragroupNbrIterator() {return new IntragroupNbrIterator(this);}
    public AtomIteratorAtomDependent makeIntergroupNbrIterator() {return new IntergroupNbrIterator(this);}
    
    public AtomSequencer makeSimpleSequencer(Atom atom) {return new SimpleSequencer(atom);}
    
    public AtomSequencer makeNeighborSequencer(Atom atom) {return new AtomSequencerCell(atom);}
    //maybe need an "AboveNbrLayerSequencer" and "BelowNbrLayerSequencer"
    
    public Class simpleSequencerClass() {return SimpleSequencer.class;}
    
    public Class neighborSequencerClass() {return AtomSequencerCell.class;}
    
    public AtomSequencer.Factory simpleSequencerFactory() {return SimpleSequencer.FACTORY;}
    
    public AtomSequencer.Factory neighborSequencerFactory() {return AtomSequencerCell.FACTORY;}
    
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates the child atoms of a basis, returning them in an order consistent
 * with neighborlist sequence but without limiting them to those neighboring a
 * reference atom.
 */
public static final class SequentialIterator implements AtomIterator {
    
    private AtomIteratorList listIterator = new AtomIteratorList();
    private AtomList neighborSequenceList = new AtomList();
    private IteratorFactoryCell factory;
    private AtomTreeNodeGroup basis;
    
    public SequentialIterator(IteratorFactoryCell f) {
        factory = f;
    }
        
	public void all(Atom atom, IteratorDirective id, final AtomAction action) {
		if(atom == null || atom.node.isLeaf() || action == null) return;
		basis = (atom != null) ? (AtomTreeNodeGroup)atom.node : null;
		if(basis.childSequencerClass().equals(AtomSequencerCell.class)) {
			BravaisLattice lattice = factory.getLattice(basis.parentPhase());
			Atom cell = lattice.siteList().getFirst();
			AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
			HashMap hash = (HashMap)lattice.agents[0];    //would like to do this a different way
			int tabIndex = ((Integer)hash.get(basis)).intValue();
			AtomLinker.Tab cellHeader = tabs[tabIndex];
			neighborSequenceList.setAsHeader(cellHeader, basis.childList.size());
			AtomIteratorList.all(cellHeader, id, action);
		} else {
			listIterator.all(atom, id, action);
		}
		
	}

   /**
     * Defines the atoms that are subject to iteration as the children of the
     * given atom.
     */
    public void setBasis(Atom a) {
        basis = (a != null) ? (AtomTreeNodeGroup)a.node : null;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setList(AtomList.NULL);
            return;
        }
        boolean iterateCells = basis.childSequencerClass().equals(AtomSequencerCell.class);
        if(iterateCells) {
            BravaisLattice lattice = factory.getLattice(basis.parentPhase());
            Atom cell = lattice.siteList().getFirst();
            AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
            HashMap hash = (HashMap)lattice.agents[0];    //would like to do this a different way
            int tabIndex = ((Integer)hash.get(basis)).intValue();
            AtomLinker.Tab cellHeader = tabs[tabIndex];
            neighborSequenceList.setAsHeader(cellHeader, basis.childList.size());
            listIterator.setList(neighborSequenceList);
        } else {
            listIterator.setBasis(a);
        }
    }
    
    /**
     * Resets iterator so that it will loop up the list of atoms beginning
     * from the first one.
     */
    public Atom reset() {return listIterator.reset();}
    
    /**
     * Sets to state in which hasNext is false.
     */
    public void unset() {listIterator.unset();}
        
    public boolean hasNext() {return listIterator.hasNext();}
    
    public boolean contains(Atom atom) {return listIterator.contains(atom);}
    
    /**
     * Resets for iteration according to the given directive.  If the directive does
     * not specify an atom, this is the same as the reset() method, except that the
     * direction of iteration is as given by the directive.  If an atom is specified,
     * iteration begins with it and proceeds up or down list from there.
     */
    public Atom reset(IteratorDirective id) {return listIterator.reset(id);}
    
    /**
     * Returns the next atom in the iteration sequence.  Assumes that hasNext is
     * true; calling when hasNext is false can lead to unpredictable results, and
     * may or may not cause an error or exception.
     */
    public Atom next() {return listIterator.next();}
    
    public void allAtoms(AtomActionAdapter act) {
        listIterator.allAtoms(act);
    }
    
    public Atom getBasis() {
        return basis.atom;
    }
    
    public int size() {
        return listIterator.size();
    }
    
    /**
     * Method to test SequentialIterator
     */
    public static void main(String args[]) {
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 6;       
	    SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	    speciesSpheres.setNMolecules(nAtoms);
	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator iterator = iteratorFactory.makeGroupIteratorSequential();
	    iterator.setBasis(phase.getAgent(speciesSpheres));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		iterator.reset();
		int k = 0;
		while(iterator.hasNext()) {
		    Atom a = iterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of SequentialIterator.main
    
}//end of SequentialIterator
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates among the children of a given basis, those atoms
 * that are cell-list neighbors of a specified atom that is
 * a child of the same basis.
 */
//would like to modify so that central atom can be any descendant of the basis.
public static final class IntragroupNbrIterator implements AtomIterator {
	
	private final IteratorDirective upSkip = new IteratorDirective(IteratorDirective.UP);
	private final IteratorDirective dnSkip = new IteratorDirective(IteratorDirective.DOWN);
    
    public IntragroupNbrIterator(IteratorFactoryCell factory) {
        iteratorFactory = factory;
        upSkip.setSkipFirst(true);
        dnSkip.setSkipFirst(true);
    }
    
	public void all(AtomSet basis, IteratorDirective id, final AtomsetAction action) {
		 if(!(basis instanceof Atom && action instanceof AtomAction)) return;
		 all((Atom)basis, id, (AtomAction)action);
	}
    
	public void all(Atom basisAtom, IteratorDirective id, final AtomAction action) {
		if(basisAtom == null || basisAtom.node.isLeaf() || action == null) return;
		Atom atom = id.atom1();
		if(atom == null) return;
		AtomTreeNodeGroup basis = (AtomTreeNodeGroup)basisAtom.node;
		if(basis.childAtomCount() == 0) return;
		boolean basisIterateCells = basis.childSequencerClass().equals(AtomSequencerCell.class);
		BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
		Polyhedron referenceCell = ((CellSequencer)atom.seq).cell();//cell in which reference atom resides
		boolean upListNow = id.direction().doUp();
		boolean doGoDown = id.direction().doDown();
		if(basisIterateCells && referenceCell != null) {
			HashMap hash = (HashMap)lattice.agents[0];
			int tabIndex = ((Integer)hash.get(basis)).intValue();//index of tabs in each cell for the basis
			AtomLinker tab = referenceCell.neighborManager().tab;
			if(upListNow) {
				//loop over rest of atoms in cell
				AtomIteratorList.all(((AtomSequencerCell)atom.seq).nbrLink, null, upSkip, action);
				//loops over atoms in uplist cells
				for(AtomLinker e=tab.next; true; e=e.next) {//loop over cells
					if(e.atom == null && ((AtomLinker.Tab)e).isHeader()) break;
					AtomLinker.Tab[] tabs = (AtomLinker.Tab[])e.atom.agents[0];
					AtomLinker next = tabs[tabIndex].next;
					while(next.atom != null) {//loop up atoms in cell
						action.actionPerformed(next.atom);
						next = next.next;
					}//end while
				}
			}//end if(upListNow)
			if(doGoDown) {
				//loop over rest of atoms in cell
				AtomIteratorList.all(((AtomSequencerCell)atom.seq).nbrLink, null, dnSkip, action);
				//loops over atoms in dnlist cells
				for(AtomLinker e=tab.previous; true; e=e.previous) {//loop over cells
					if(e.atom == null && ((AtomLinker.Tab)e).isHeader()) break;
					AtomLinker.Tab[] tabs = (AtomLinker.Tab[])e.atom.agents[0];
					AtomLinker next = tabs[tabIndex].nextTab.previous;//get the last atom on the cell marked by tabs[tabIndex]
					while(next.atom != null) {//loop down atoms in cell
						action.actionPerformed(next.atom);
						next = next.previous;
					}//end while
				}				
			}//end if(doGoDown)			
		} else { //no cell-based iteration
			AtomIteratorList.all(atom.seq, id, action);
		}
	}

    /**
     * Indicates if another iterate is forthcoming.
     */
    public boolean hasNext() {return listIterator.hasNext();}
    
    /**
     * True if the parent group of the given atom is the current basis for the iterator.
     * False otherwise, or if atom or basis is null.
     */
    public boolean contains(Atom atom) {
        return atom != null && basis != null && atom.node.parentNode() == basis;
    }
    
    /**
     * Sets to state in which hasNext is false.
     */
    public void unset() {listIterator.unset();}
    
    /**
     * Does reset if atom in iterator directive is child of the current basis.  
     * Sets hasNext false if given atom does is not child of basis.  Throws
     * an IllegalArgumentException if directive does not specify an atom.
     */
    public Atom reset(IteratorDirective id) {
        direction = id.direction();
        return doReset(id.atom1());
    }
    
    //we assume that the only Tab links in the list are those demarking
    //the beginning of each cell's sequence; thus we reset the list iterator
    //using null as the terminator
    
    public Atom reset(Atom atom) {
        return doReset(atom);
    }
    
    private Atom doReset(Atom atom) {
        referenceAtom = atom;
        if(atom == null) 
            throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");

//        direction = IteratorDirective.BOTH; //why was this ever here?

        //probably need isDescendedFrom instead of parentGroup here
        if(atom.node.parentNode() != basis) {
            throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator referencing an atom not in group of basis");
        }
        if(iterateCells) {
            referenceCell = ((AtomSequencerCell)atom.seq).cell();
            cellIterator.setBasis(referenceCell);
        }
        return doReset();
    }
    
    private Atom doReset() {
        listIterator.setSkipFirstAtom(true);
        upListNow = direction.doUp();
        doGoDown = direction.doDown();
        if(iterateCells) {
            listIterator.unset();
            if(upListNow) {
                cellIterator.reset(IteratorDirective.UP);//set cell iterator to return first up-neighbor of reference cell
                listIterator.reset(((AtomSequencerCell)referenceAtom.seq).nbrLink, null, IteratorDirective.UP);
            }
            if(!listIterator.hasNext()) advanceCell();
        } else {//no cell iteration
            listIterator.reset(referenceAtom.seq, direction);
        }
        return listIterator.peek();
    }
    // Moves to next cell that has an iterate
    private void advanceCell() {
        do {
            if(cellIterator.hasNext()) {
                listIterator.setSkipFirstAtom(false);
                Atom cell = cellIterator.next();
                AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
                if(upListNow) {
                    listIterator.reset(tabs[tabIndex], null, IteratorDirective.UP);
                } else {
                    listIterator.reset(tabs[tabIndex].nextTab, null, IteratorDirective.DOWN);
                }
            } else if(doGoDown) {//no more cells that way; see if should now reset to look at down-cells
                listIterator.setSkipFirstAtom(true);
                cellIterator.reset(IteratorDirective.DOWN);//set cell iterator to return first down neighbor of reference cell
                listIterator.reset(((AtomSequencerCell)referenceAtom.seq).nbrLink, null, IteratorDirective.DOWN);
                upListNow = false;
                doGoDown = false;
            } else {//no more cells at all
                break;
            }
        } while(!listIterator.hasNext());
    }

    /**
     * Performs given action for each child atom of basis.
     */
    public void allAtoms(AtomActionAdapter act) {
        doReset();
        if(iterateCells) {
            while(listIterator.hasNext()) {
                listIterator.allAtoms(act);
                advanceCell();
            }
        } else {
            listIterator.allAtoms(act);
        }
    }
            
    public Atom next() {
        Atom atom = listIterator.next();
        if(!listIterator.hasNext() && iterateCells) advanceCell();
        return atom;
    }
    
    /**
     * Throws RuntimeException because this is a neighbor iterator, and must
     * be reset with reference to an atom.
     */
    public Atom reset() {
        throw new RuntimeException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");
    }
    
    /**
     * Sets the given atom as the basis, so that child atoms of the
     * given atom will be returned upon iteration.  If given atom is
     * a leaf atom, a class-cast exception will be thrown.
     */
    public void setBasis(Atom atom) {
        setBasis((AtomTreeNodeGroup)atom.node);
    }
    
    //may be room for efficiency here
    public void setBasis(AtomTreeNodeGroup node) {
        basis = node;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setList(AtomList.NULL);
            iterateCells = false;
            return;
        }
        //can base decision whether to iterate over cells on type of sequencer
        //for given atom, because it is in the group of atoms being iterated
        iterateCells = basis.childSequencerClass().equals(AtomSequencerCell.class);
        BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
        listIterator.setList(node.childList);
        if(iterateCells) {
            HashMap hash = (HashMap)lattice.agents[0];
            tabIndex = ((Integer)hash.get(node)).intValue();
        }
    }
    
    /**
     * Returns the current iteration basis.
     */
    public Atom getBasis() {return (basis != null) ? basis.atom() : null;}
    
    /**
     * The number of atoms in the current basis.  This will differ from
     * the number of iterates given by the iterator, because the iterator
     * will return only those atoms neighboring a reference atom, which
     * in general is not all the atoms in the basis.
     */
    public int size() {
       return (basis != null) ? basis.childAtomCount() : 0;
    }   

    private AtomTreeNodeGroup basis;
    private Atom next;
    private Atom referenceAtom;
    private boolean upListNow, doGoDown;
    private IteratorDirective.Direction direction = IteratorDirective.BOTH;
    private Polyhedron referenceCell;
    private boolean iterateCells;
    private int tabIndex;
    private BravaisLattice lattice;
    private final SiteIteratorNeighbor cellIterator = new SiteIteratorNeighbor();
    private final AtomIteratorList listIterator = new AtomIteratorList();
    private final IteratorFactoryCell iteratorFactory;

    /**
     * Method to test IntragroupNbrIterator
     */
    public static void main(String args[]) {
        Default.ATOM_SIZE = 1.0;
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 5;       
	    SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	    speciesSpheres.setNMolecules(nAtoms);
	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator sequenceIterator = iteratorFactory.makeGroupIteratorSequential();
	    AtomIterator iterator = iteratorFactory.makeIntragroupNbrIterator();
	    sequenceIterator.setBasis(phase.getAgent(speciesSpheres));
	    iterator.setBasis(phase.getAgent(speciesSpheres));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		sequenceIterator.reset();
		int k = 0;
		while(sequenceIterator.hasNext()) {
		    Atom a = sequenceIterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
		System.out.println(" first: "+first.signature());
		System.out.println("middle: "+middle.signature());
		System.out.println("  last: "+last.signature());
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of IntragroupNbrIterator.main

}//end of IntragroupNbrIterator class

/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates among the children of a given basis, those atoms
 * that are cell-list neighbors of a specified atom that is
 * a child of a different basis.
 */
//would like to modify so that central atom can be any descendant of the basis.
public static final class IntergroupNbrIterator implements AtomIterator {
    
    public IntergroupNbrIterator(IteratorFactoryCell factory) {
        iteratorFactory = factory;
    }
    
	public void all(AtomSet basis, IteratorDirective id, final AtomsetAction action) {
		 if(!(basis instanceof Atom && action instanceof AtomActionAdapter)) return;
		 all((Atom)basis, id, (AtomAction)action);
	}
    
	public void all(Atom basisAtom, IteratorDirective id, final AtomAction action) {
		if(basisAtom == null || basisAtom.node.isLeaf() || action == null) return;
		Atom atom = id.atom1();
		if(atom == null) return;
		AtomTreeNodeGroup basis = (AtomTreeNodeGroup)basisAtom.node;
		if(basis.childAtomCount() == 0) return;
		boolean basisIterateCells = basis.childSequencerClass().equals(AtomSequencerCell.class);
		BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
		Polyhedron referenceCell = ((CellSequencer)atom.seq).cell();//cell in which reference atom resides
		if(basisIterateCells && referenceCell != null) {
			HashMap hash = (HashMap)lattice.agents[0];
			int tabIndex = ((Integer)hash.get(basis)).intValue();//index of tabs in each cell for the basis
			AtomLinker.Tab header = referenceCell.neighborManager().neighbors().header;
			for(AtomLinker e=header.next; e!=header; e=e.next) {//loop over cells
				if(e.atom == null) continue;
				AtomLinker.Tab[] tabs = (AtomLinker.Tab[])e.atom.agents[0];
				AtomLinker next = tabs[tabIndex].next;
				while(next.atom != null) {//loop over atoms in cell
					action.actionPerformed(next.atom);
					next = next.next;
				}//end while
			}
		} else {
			simpleIterator.all(basis.childList, null, action);
		}
	}//end of all

   /**
     * Indicates if another iterate is forthcoming.
     */
    public boolean hasNext() {return atomIterator.hasNext();}
    
    /**
     * True if the parent group of the given atom is the current basis for the iterator.
     * False otherwise, or if atom or basis is null.
     */
    public boolean contains(Atom atom) {
        return atom != null && basis != null && atom.node.parentNode() == basis;
    }
    
    /**
     * Sets iterators such that hasNext is false.
     */
    public void unset() {
        simpleIterator.unset();
        atomIterator = simpleIterator;
    }
    
    /**
     * Does reset if atom in iterator directive is child of the current basis.  
     * Sets hasNext false if given atom does is not child of basis.  Throws
     * an IllegalArgumentException if directive does not specify an atom.
     * Ignores direction.
     */
    public Atom reset(IteratorDirective id) {
        return doReset(id.atom1());
    }
    
    public Atom reset(Atom atom) {
        return doReset(atom);
    }
    
    //select iterators and set basis
    private Atom doReset(Atom atom) {
        if(atom == null) throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");

        if(basisIterateCells) {
            Polyhedron referenceCell = ((CellSequencer)atom.seq).cell();
            iterateCells = (referenceCell != null);
            if(iterateCells) simpleIterator.setList(referenceCell.neighborManager().neighbors());
        } else {
            iterateCells = false;
        }
        
        if(iterateCells) {//simple iterator is cell iterator
            listIterator.setBasis(basis);
            atomIterator = listIterator;
        } else { //simple iterator is atom iterator
            simpleIterator.setList(basis.childList);
            atomIterator = simpleIterator;
        }
        
        //reset iterators
        return doReset();
    }
    
    private Atom doReset() {
        if(iterateCells) {
            simpleIterator.reset();//reset cell iterator
            advanceCell();//reset list iterator
            return listIterator.peek();
        } else {//no cell iteration
            return simpleIterator.reset();
        }
    }
    
    // Moves to next cell that has an iterate
    private void advanceCell() {
        do {
            if(simpleIterator.hasNext()) {//cell iterator
                Atom cell = simpleIterator.next();
                AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
                listIterator.reset(tabs[tabIndex], null, IteratorDirective.UP);
            } else {//no more cells at all
                break;
            }
        } while(!listIterator.hasNext());
    }

    /**
     * Performs given action for each child atom of basis.
     */
    public void allAtoms(AtomActionAdapter act) {
        doReset();
        if(iterateCells) {
            while(listIterator.hasNext()) {
                listIterator.allAtoms(act);
                advanceCell();
            }
        } else {
            simpleIterator.allAtoms(act);
        }
    }
            
    public Atom next() {
        Atom atom = atomIterator.next();
        if(!listIterator.hasNext() && iterateCells) advanceCell();
        return atom;
    }
    
    /**
     * Throws RuntimeException because this is a neighbor iterator, and must
     * be reset with reference to an atom.
     */
    public Atom reset() {
        throw new RuntimeException("Cannot reset IteratorFactoryCell.IntergroupNbrIterator without referencing an atom");
    }
    
    /**
     * Sets the given atom as the basis, so that child atoms of the
     * given atom will be returned upon iteration.  If given atom is
     * a leaf atom, a class-cast exception will be thrown.
     */
    public void setBasis(Atom atom) {
        setBasis((AtomTreeNodeGroup)atom.node);
    }
    
    //may be room for efficiency here
    public void setBasis(AtomTreeNodeGroup node) {
        basis = node;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setList(AtomList.NULL);
            basisIterateCells = false;
            return;
        }
        basisIterateCells = basis.childSequencerClass().equals(AtomSequencerCell.class);
        BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
        listIterator.setList(node.childList);
        if(basisIterateCells) {
            HashMap hash = (HashMap)lattice.agents[0];
            tabIndex = ((Integer)hash.get(node)).intValue();
        }
    }
    
    /**
     * Returns the current iteration basis.
     */
    public Atom getBasis() {return basis.atom();}
    
    /**
     * The number of atoms in the current basis.  This will differ from
     * the number of iterates given by the iterator, because the iterator
     * will return only those atoms neighboring a reference atom, which
     * in general is not all the atoms in the basis.
     */
    public int size() {
       return (basis != null) ? basis.childAtomCount() : 0;
    }   

    private AtomTreeNodeGroup basis;
    private Atom next;
    private boolean basisIterateCells, iterateCells;
    private int tabIndex;
    private BravaisLattice lattice;
    private final AtomIteratorList listIterator = new AtomIteratorList();
    private final AtomIteratorListSimple simpleIterator = new AtomIteratorListSimple();
    private final IteratorFactoryCell iteratorFactory;
    private AtomIterator atomIterator;//set to iterator that provides the atoms

    /**
     * Method to test IntergroupNbrIterator
     */
    public static void main(String args[]) {
        Default.ATOM_SIZE = 1.0;
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 50;       
	    SpeciesSpheresMono speciesSpheres1 = new SpeciesSpheresMono();
	    SpeciesSpheresMono speciesSpheres2 = new SpeciesSpheresMono();
	    speciesSpheres1.setNMolecules(nAtoms);
	    speciesSpheres2.setNMolecules(nAtoms);
//	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator sequenceIterator = iteratorFactory.makeGroupIteratorSequential();
	    AtomIterator iterator = iteratorFactory.makeIntergroupNbrIterator();
	    sequenceIterator.setBasis(phase.getAgent(speciesSpheres1));
	    iterator.setBasis(phase.getAgent(speciesSpheres2));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		sequenceIterator.reset();
		int k = 0;
		while(sequenceIterator.hasNext()) {
		    Atom a = sequenceIterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
		System.out.println(" first: "+first.signature());
		System.out.println("middle: "+middle.signature());
		System.out.println("  last: "+last.signature());
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of IntergroupNbrIterator.main

}//end of IntergroupNbrIterator class

/////////////////////////////////////////////////////////////////////////////////////////////

public interface CellSequencer {
    
    /**
     * Method called to notify sequencer that the phase has a new cell lattice.
     */
	public void latticeChangeNotify();
	public void setParentNotify(AtomTreeNodeGroup parent);
    
    public Polyhedron cell();
    
}//end of CellSequencer interface
   
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Sequencer used for atoms that are not being neighbor listed.
 */
public static final class SimpleSequencer extends AtomSequencer implements CellSequencer {
    
    public SimpleSequencer(Atom a) {super(a);}
    
    /**
     * CellSequencer interface method; performs no action except to pass event
     * on to sequencers of child atoms.
     */
    public void latticeChangeNotify() {
        if(atom.node.isLeaf()) return;
        else {
            AtomIteratorListSimple iterator = new AtomIteratorListSimple(((AtomTreeNodeGroup)atom.node).childList);
            while(iterator.hasNext()) ((CellSequencer)iterator.next().seq).latticeChangeNotify();
        }
    }
    
    public Polyhedron cell() {
        Atom parent = atom.node.parentGroup();
        return (parent != null) ? ((CellSequencer)parent.seq).cell() : null;
    }

    /**
     * Performs no action.
     */
    public void moveNotify() {}
    
    /**
     * Performs no action.
     */
    public void setParentNotify(AtomTreeNodeGroup newParent) {
//		if(atom.node.isLeaf()) return;
//		else {
//			AtomIteratorListSimple iterator = new AtomIteratorListSimple(((AtomTreeNodeGroup)atom.node).childList);
//			while(iterator.hasNext()) ((CellSequencer)iterator.next().seq).setParentNotify((AtomTreeNodeGroup)atom.node);
//		}
    }
    
    /**
     * Returns true if this atom preceeds the given atom in the atom sequence.
     * Returns false if the given atom is this atom, or (of course) if the
     * given atom instead preceeds this one.  Returns true if the given atom is null.
     */
    public boolean preceeds(Atom a) {
//        throw new RuntimeException("IteratorFactoryCell.Sequencer.preceeds method should be checked for correctness before using");
//        //want to return false if atoms are the same atoms
        if(a == null) return true;
        if(atom.node.parentNode() == a.node.parentNode()) return atom.node.index() < a.node.index();//works also if both parentGroups are null
        int thisDepth = atom.node.depth();
        int atomDepth = a.node.depth();
        if(thisDepth == atomDepth) return atom.node.parentGroup().seq.preceeds(a.node.parentGroup());
        else if(thisDepth < atomDepth) return this.preceeds(a.node.parentGroup());
        else /*this.depth > atom.depth*/ return atom.node.parentGroup().seq.preceeds(a);
    }
    
    public static final AtomSequencer.Factory FACTORY = new AtomSequencer.Factory() {
        public AtomSequencer makeSequencer(Atom atom) {
            return new SimpleSequencer(atom);
        }
        public Class sequencerClass() {return SimpleSequencer.class;}
    };
}

/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates through the cells of the given lattice, and adds a tab to the 
 * given list for each cell, and extends the tablist in each cell to reference
 * its new tab.
 */
private static void setupListTabs(BravaisLattice lattice/*, AtomList list*/) {
    AtomIteratorList iterator = new AtomIteratorList(lattice.siteList());
    iterator.reset();
    AtomLinker.Tab[] headerList = null;
    while(iterator.hasNext()) {//loop over cells
        Site site = (Site)iterator.nextAtom();
        if(site.agents == null || site.agents[0] == null) {
            site.agents = new Object[1];
            site.agents[0] = new AtomLinker.Tab[0];
        }
        AtomLinker.Tab[] tabList = (AtomLinker.Tab[])site.agents[0];
        AtomLinker.Tab[] newTabList = new AtomLinker.Tab[tabList.length+1];
        for(int i=0; i<tabList.length; i++) newTabList[i] = tabList[i];
        AtomLinker.Tab newTab = AtomLinker.newTab();
        newTabList[tabList.length] = newTab;
        if(headerList == null) headerList = newTabList;
        else newTab.addBefore(headerList[tabList.length]);
 //       list.add(newTab);
        site.agents[0] = newTabList;
    }
}//end of setupListTabs

    /**
     * Demonstrates how this class is implemented.
     */
    public static void main(String[] args) {
        
  //      SequentialIterator.main(args); 
  //      IntragroupNbrIterator.main(args); 
  //      IntergroupNbrIterator.main(args); 
        boolean cellListing = true;
        boolean doDisplay = true;
        boolean md = true;
        int nAtoms = 90;
        boolean fixedLengthRun = false;
        boolean mixture = true;
        
        System.out.println(cellListing ? "cellListing" : "no cellListing");
        System.out.println(md ? "md" : "mc");
        System.out.println("number of atoms in simulation: "+2*nAtoms);
        
        Default.ATOM_SIZE = 150./(double)nAtoms;
//		Default.ATOM_SIZE = 3;
        etomica.graphics.SimulationGraphic sim = new etomica.graphics.SimulationGraphic(new Space2D());
        Simulation.instance = sim;

        if(cellListing) sim.setIteratorFactory(new IteratorFactoryCell(sim));
        
        Integrator integrator = null;
        if(md) {
	        integrator = new IntegratorHard();
            ((IntegratorHard)integrator).setTimeStep(0.01);
        } else {
            integrator = new IntegratorMC();
            MCMoveAtom mcMoveAtom = new MCMoveAtom((IntegratorMC)integrator);
            //MCMoveVolume mcMoveVolume = new MCMoveVolume((IntegratorMC)integrator);
            //mcMoveVolume.setPressure(3.0);
        }
        
	    Controller controller = new Controller();
	    etomica.graphics.DisplayPhase displayPhase = null;
	    if(doDisplay) displayPhase = new etomica.graphics.DisplayPhase();

        if(!mixture) {
	        SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	        speciesSpheres.setNMolecules(2*nAtoms);
	        if(doDisplay) etomica.graphics.ColorSchemeByType.setColor(speciesSpheres, java.awt.Color.green);
	    	    
	        Potential2 potential = new P2HardSphere();
	        sim.hamiltonian.potential.setSpecies(potential, new Species[] {speciesSpheres,speciesSpheres});
	    } else {
	        SpeciesSpheresMono speciesSpheres1 = new SpeciesSpheresMono();
	        SpeciesSpheresMono speciesSpheres2 = new SpeciesSpheresMono();
	        speciesSpheres1.setNMolecules(nAtoms);
	        speciesSpheres2.setNMolecules(nAtoms);
	        if(doDisplay) {
	            etomica.graphics.ColorSchemeByType.setColor(speciesSpheres1, java.awt.Color.green);
	            etomica.graphics.ColorSchemeByType.setColor(speciesSpheres2, java.awt.Color.black);
	        }
	    	    
	        Potential2 potential11 = new P2HardSphere();
	     //   Potential2 potential12 = new P2HardSphere();
	        Potential2 potential12 = new P2SquareWell();
	        Potential2 potential22 = new P2HardSphere();
	        sim.hamiltonian.potential.setSpecies(potential11, new Species[] {speciesSpheres1, speciesSpheres1});
	        sim.hamiltonian.potential.setSpecies(potential12, new Species[] {speciesSpheres2, speciesSpheres1});
	        sim.hamiltonian.potential.setSpecies(potential22, new Species[] {speciesSpheres2, speciesSpheres2});
        }
        
	    Phase phase = new Phase();//must come after species!
//		etomica.graphics.DeviceTrioControllerButton buttons = new etomica.graphics.DeviceTrioControllerButton(controller);
       
	    etomica.graphics.LatticeRenderer.ColorSchemeNeighbor colorSchemeNbr = null; 
	    etomica.graphics.LatticeRenderer.ColorSchemeCell colorSchemeCell = null;
        if(doDisplay) {
            if(cellListing) {
	            colorSchemeNbr = new etomica.graphics.LatticeRenderer.ColorSchemeNeighbor(sim);
	            colorSchemeCell = new etomica.graphics.LatticeRenderer.ColorSchemeCell();
	        }
	    }
    	    
	    integrator.setDoSleep(true);
	    integrator.setSleepPeriod(2);
	    
	    
        //this method call invokes the mediator to tie together all the assembled components.
		Simulation.instance.elementCoordinator.go();
		
		if(cellListing) {

	        BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    //    ((IteratorFactoryCell)sim.iteratorFactory).setNeighborRange(4.0);
    	
	        if(doDisplay) {
	            //draw lattice cells on display
	    //      etomica.graphics.LatticeRenderer latticeRenderer = 
	    //              new etomica.graphics.LatticeRenderer(lattice);
	    //      displayPhase.addDrawable(latticeRenderer);
    	  
	            //color atoms
	            colorSchemeNbr.setAtom(phase.speciesMaster.atomList.getRandom());
	            displayPhase.setColorScheme(colorSchemeNbr);
        //        colorSchemeCell.setLattice(lattice);
        //	    displayPhase.setColorScheme(colorSchemeCell);
            }
        }
        
        if(doDisplay) etomica.graphics.SimulationGraphic.makeAndDisplayFrame(sim);
        
        if(fixedLengthRun) {
            if(md) integrator.setMaxSteps(1000);
            else   integrator.setMaxSteps(100*nAtoms*2);
        }
//        integrator.initialize();
        System.out.println("Starting");
//        etomica.benchmark.Stopwatch timer = new etomica.benchmark.Stopwatch().start();
//        integrator.run();
//        timer.stop();
//        System.out.println("Elapsed time: "+0.001*timer.getElapsedTime());
        
     //   controller.start();
    }//end of main
    
    
   
}//end of IteratorFactoryCell