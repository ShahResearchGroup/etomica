package etomica;
import etomica.utility.java2.HashMap;

import etomica.lattice.*;
import etomica.utility.java2.Iterator;

/**
 * Iterator factory that uses a cell-based neighbor list.  Constructed
 * and functions as follows.<br>
 * Factory is attached to a simulation by invoking the setIteratorFactory method
 * (in Simulation) with an instance of this factory as an argument.
 * Mediator is placed in simulation when this factory is constructed.  This
 * mediator causes a cell lattice to be attached to each phase.
 * Atom factories decide whether each atom it constructs is given a simple
 * sequencer or a neighbor sequencer; this specification is made by passing
 * to the atom's constructor the corresponding sequencer factory given
 * by the make*SequencerFactory methods of this iterator factory.  Usually
 * neighbor sequencers are given to molecules, and simple sequencers are
 * used for the atoms and groups they comprise.  In large molecules (e.g. polymers)
 * it may be the subgroups of each molecule that are organized into the cells.<br>
 *
 * Atom is first assigned to its cell when it is constructed in the AtomFactory.makeAtom
 * method.  Its cell assignment is updated every time a translate method is
 * called in its coordinate class (translateTo, translateBy, etc. all perform a call
 * to moveNotify method of the atom's sequencer after doing the move).  The assignment
 * is also updated whenever the setParent method of the node is called (sequencer
 * is informed via its setParentNotify method) or if the [to be implemented] reset
 * method of the iterator factory is called (either directly, or by the registered observer
 * of the lattice when it is informed of a change in the lattice constant or dimensions).
 * The childList of the parent of cell-listed atoms organizes the atoms via their
 * sequencers, which are subclasses of AtomLinker.  The childList contains Tabs that 
 * demark the set of sequencers contained in a given cell.  As an atom moves from one
 * cell to another, it is shuffled in the childList into the segment corresponding
 * to its new cell.  Each cell references separately a fixed set of neighbor cells, and atoms within
 * those cells are accessed for each neighbor cell through the tab it has in the
 * childList.  (actually, the NeighborSequencer contains an "inner" atomlinker that
 * is used to maintain the cell structure; the "main" sequence generally does not
 * change and doesn't keep the cell ordering.  It was found necessary to use two sequences
 * for the times when looping through the atoms and translating each in space; each
 * translation potentially modifies the cell-list sequence, so to get through the 
 * list properly the fixed-sequence option is needed).  The neighbor and sequential
 * iterators generated by this factory adhere to the cell-list sequencing; list iterators
 * generated directly (externally to this factory) will loop through the fixed (not
 * cell-ordered) sequence when given the parent's childList as its basis.
 *
 * @author David Kofke
 * 02.02.05
 * 
 */

public class IteratorFactoryCell implements IteratorFactory {
    
    private Primitive primitive;
    private Simulation simulation;
    private int[] dimensions;
    private BravaisLattice[] deployedLattices = new BravaisLattice[0];
    private double neighborRange;
    
    /**
     * Constructs a new iterator factory for the given simulation, using
     * cubic cells for the neighbor listing.  Does not automatically
     * register the factory with the simulation; this must be done
     * separately using the simulation's setIteratorFactory method.
     * For Simulation sim, at typical call is
     * sim.setIteratorFactory(new IteratorFactoryCell(sim));
     */
    public IteratorFactoryCell(Simulation sim) {
        this(sim, new PrimitiveCubic(sim.space), 10);
    }
    
    /**
     * Constructs a new iterator factory for the given simulation, using
     * cells based on the given primitive.  Does not automatically
     * register the factory with the simulation; this must be done
     * separately using the simulation's setIteratorFactory method.
     *
     * @sim          The simulation in which this factory is being used
     * @primitive    The primitive class that defines the type of unit cell used to construct the neighbor-cell lattice
     * @param nCells the number of cell in each dimension; total number of cells is then nCells^D.
     */
    public IteratorFactoryCell(Simulation sim, Primitive primitive, int nCells) {
        this.simulation = sim;
        this.primitive = primitive;
        neighborRange = Default.ATOM_SIZE;
        dimensions = new int[sim.space.D()];
        for(int i=0; i<sim.space.D(); i++) dimensions[i] = nCells;
        
        //Add mediator that places a cell lattice in each phase.
        sim.mediator().addMediatorPair( new Mediator.PhaseNull(sim.mediator()) {
            public void add(Phase phase) {makeCellLattice(phase);}
        });        
    }
    
    /**
     * Constructs the cell lattice used to organize all cell-listed atoms
     * in the given phase.  Each new lattice is set up with its own instance
     * of the primitive, formed by copying the instance associated with this factory.  
     * Note that the phase does not contain any reference
     * to the lattice.  Its association with the phase is made through the 
     * deployedLattices array kept by this iterator factory class, and by 
     * the reference in each neighbor sequencer to the cell containing its atom.
     */
    public BravaisLattice makeCellLattice(final Phase phase) {
        if(phase.parentSimulation() != simulation) throw new IllegalArgumentException("Attempt to apply iterator factory to a phase from a different simulation"); 
        //make the unit cell factory and set it to produce cells of the appropriate size
        final Primitive primitiveCopy = primitive.copy();//each new lattice works with its own primitive
///        AtomFactory cellFactory = primitiveCopy.unitCellFactory();
        Space.Vector primitiveSize = simulation.space.makeVector();
        primitiveSize.E(phase.boundary().dimensions());
        primitiveSize.DE(Space.makeVector(dimensions));
        primitiveCopy.setSize(primitiveSize.toArray());
        //construct the lattice
///        AtomFactory latticeFactory = new BravaisLattice.Factory(simulation, cellFactory, dimensions, primitiveCopy);
///        final BravaisLattice lattice = (BravaisLattice)latticeFactory.makeAtom();
        final BravaisLattice lattice = BravaisLattice.makeUnitCellLattice(simulation.space, dimensions, primitiveCopy);
        lattice.shiftFirstToOrigin();
        primitiveCopy.setLattice(null);
        
        //set up the neighbor lists for each cell in the lattice
        etomica.lattice.NeighborManager.Criterion neighborCriterion = new etomica.lattice.NeighborManager.Criterion() {
            public boolean areNeighbors(Site s1, Site s2) {
                return ((AbstractCell)s1).r2NearestVertex((AbstractCell)s2, phase.boundary()) < neighborRange;
            }
        };
        lattice.setupNeighbors(neighborCriterion);
        
        //instantiate the hashmap that will hold the index Integers that
        //are keyed to the the parentGroup of cell-listed set of children
        lattice.agents = new Object[1];
        lattice.agents[0] = new HashMap();
        
        //resize and update array that enables lookup of the lattice in any given phase
        int latticeCountOld = deployedLattices.length;
        if(phase.index >= latticeCountOld) {
            BravaisLattice[] newArray = new BravaisLattice[phase.index+1];
            for(int i=0; i<latticeCountOld; i++) newArray[i] = deployedLattices[i];
            deployedLattices = newArray;
        }
        deployedLattices[phase.index] = lattice;
        
        //add listener to notify all sequencers of any lattice events (resizing of lattice, for example)
        lattice.eventManager.addListener(new LatticeListener() {
            public void actionPerformed(LatticeEvent evt) {
                if(evt.type() == LatticeEvent.REBUILD || evt.type() == LatticeEvent.ALL_SITE) {
                    Phase p = getPhase((BravaisLattice)evt.lattice());
                    if(p == null) return;
                    AtomIteratorMolecule iterator = new AtomIteratorMolecule(p);
                    while(iterator.hasNext()) ((CellSequencer)iterator.next().seq).latticeChangeNotify();
                }//end if
            }
        });
        
        //add listener to phase to update the size and placement of the lattice
        //cells if the phase undergoes an inflation of its boundary.
        //An inflation event should not, however, cause the molecules to be reassigned
        //to their lattice cells, since the atom positions and the cells scale proportionately
        //Atoms in molecules may be reassigned, if they are the focus of neighbor listing (which is not usually the case)
        phase.boundaryEventManager.addListener(new PhaseListener() {
            final AtomIteratorListSimple cellIterator = new AtomIteratorListSimple();
            double[] newSize;
            public void actionPerformed(PhaseEvent evt) {
                if(!evt.type().equals(PhaseEvent.BOUNDARY_INFLATE)) return;
                    //we expect that primitive.lattice() == null, so change of size doesn't cause replacement of atoms in cells
                if(evt.isotropic) {
                    primitiveCopy.scaleSize(evt.isoScale);
                    cellIterator.setBasis(lattice.siteList());
                    cellIterator.reset();
                    while(cellIterator.hasNext()) {
                        cellIterator.next().coord.inflate(evt.isoScale);
                    }
                } else {//anisotropic inflation
                    if(primitiveCopy instanceof PrimitiveCubic) throw new RuntimeException("Cannot handle anisotropic inflate with cubic primitive used in IteratorFactoryCell");
                    newSize = ((PrimitiveOrthorhombic)primitiveCopy).getSize();
                    for(int i=0; i<newSize.length; i++) newSize[i] *= evt.anisoScale.x(i);
                    primitiveCopy.setSize(newSize);
                    cellIterator.setBasis(lattice.siteList());
                    cellIterator.reset();
                    while(cellIterator.hasNext()) {
                        cellIterator.next().coord.inflate(evt.anisoScale);
                    }
                }
            }//end actionPerformed
        });
        return lattice;
    }//end of makeCellLattice method
    
    /**
     * Returns the cell lattice corresponding to the given phase.
     */
    public BravaisLattice getLattice(Phase phase) {
        if(phase == null) return null;
        else return deployedLattices[phase.index];
    }
    
    /**
     * Returns the phase corresponding to the given cell lattice.
     */
    public Phase getPhase(BravaisLattice lattice) {
        if(lattice == null) return null;
        //check all phases that have been added to the simulation
        for(Iterator ip=simulation.phaseList().iterator(); ip.hasNext(); ) {
            Phase phase = (Phase)ip.next();
            if(getLattice(phase) == lattice) return phase;
        }
        return null;//no phase corresponding to given lattice found in simulation
    }
    
    /**
     * Sets the maximum range of interaction for which the cells must keep neighbors.
     * Updates the neighbor lists of all previous and future cell lattices consistent
     * with the new value.
     */
    public void setNeighborRange(double r) {
        neighborRange = r;
        final double rangeSquared = r*r;
        for(int i=0; i<deployedLattices.length; i++) {
            final Phase phase = getPhase(deployedLattices[i]);
            etomica.lattice.NeighborManager.Criterion neighborCriterion = new etomica.lattice.NeighborManager.Criterion() {
                public boolean areNeighbors(Site s1, Site s2) {
                    return ((AbstractCell)s1).r2NearestVertex((AbstractCell)s2, phase.boundary()) < rangeSquared;
                }
            };
            deployedLattices[i].setupNeighbors(neighborCriterion);
        }
    }
    /**
     * Accessor method for the maximum range of interaction for which cells must keep neighbors.
     */
    public double getNeighborRange() {return neighborRange;}


    public AtomIterator makeGroupIteratorSequential() {
        return new SequentialIterator(this);
    }
        
    public AtomIterator makeIntragroupNbrIterator() {return new IntragroupNbrIterator(this);}
    public AtomIterator makeIntergroupNbrIterator() {return new IntergroupNbrIterator(this);}
    
    public AtomSequencer makeSimpleSequencer(Atom atom) {return new SimpleSequencer(atom);}
    
    public AtomSequencer makeNeighborSequencer(Atom atom) {return new NeighborSequencer(atom);}
    //maybe need an "AboveNbrLayerSequencer" and "BelowNbrLayerSequencer"
    
    public Class simpleSequencerClass() {return SimpleSequencer.class;}
    
    public Class neighborSequencerClass() {return NeighborSequencer.class;}
    
    public AtomSequencer.Factory simpleSequencerFactory() {return SimpleSequencer.FACTORY;}
    
    public AtomSequencer.Factory neighborSequencerFactory() {return NeighborSequencer.FACTORY;}
    
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates the child atoms of a basis, 
 * returning them in an order consistent with neighborlist sequence but
 * without limiting them to those neighboring a reference atom.
 */
public static final class SequentialIterator extends AtomIterator {
    
    private AtomIteratorList listIterator = new AtomIteratorList();
    private AtomList neighborSequenceList = new AtomList();
    private IteratorFactoryCell factory;
    private AtomTreeNodeGroup basis;
    
    public SequentialIterator(IteratorFactoryCell f) {
        factory = f;
    }
        
	public void all(Atom basis, IteratorDirective id, final AtomActive action) {
		if(basis == null || basis.node.isLeaf() || action == null) return;
		throw new etomica.exception.MethodNotImplementedException();
	}

   /**
     * Defines the atoms that are subject to iteration as the children of the
     * given atom.
     */
    public void setBasis(Atom a) {
        basis = (a != null) ? (AtomTreeNodeGroup)a.node : null;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setBasis(AtomList.NULL);
            return;
        }
        boolean iterateCells = basis.childSequencerClass().equals(NeighborSequencer.class);
        if(iterateCells) {
            BravaisLattice lattice = factory.getLattice(basis.parentPhase());
            Atom cell = lattice.siteList().getFirst();
            AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
            HashMap hash = (HashMap)lattice.agents[0];    //would like to do this a different way
            int tabIndex = ((Integer)hash.get(basis)).intValue();
            AtomLinker.Tab cellHeader = tabs[tabIndex];
            neighborSequenceList.setAsHeader(cellHeader, basis.childList.size());
            listIterator.setBasis(neighborSequenceList);
        } else {
            listIterator.setBasis(a);
        }
    }
    
    /**
     * Resets iterator so that it will loop up the list of atoms beginning
     * from the first one.
     */
    public Atom reset() {return listIterator.reset();}
    
    /**
     * Sets to state in which hasNext is false.
     */
    public void unset() {listIterator.unset();}
        
    public boolean hasNext() {return listIterator.hasNext();}
    
    public boolean contains(Atom atom) {return listIterator.contains(atom);}
    
    /**
     * Resets for iteration according to the given directive.  If the directive does
     * not specify an atom, this is the same as the reset() method, except that the
     * direction of iteration is as given by the directive.  If an atom is specified,
     * iteration begins with it and proceeds up or down list from there.
     */
    public Atom reset(IteratorDirective id) {return listIterator.reset(id);}
    
    /**
     * Returns the next atom in the iteration sequence.  Assumes that hasNext is
     * true; calling when hasNext is false can lead to unpredictable results, and
     * may or may not cause an error or exception.
     */
    public Atom next() {return listIterator.next();}
    
    public void allAtoms(AtomAction act) {
        listIterator.allAtoms(act);
    }
    
    public Atom getBasis() {
        return basis.atom;
    }
    
    public int size() {
        return listIterator.size();
    }
    
    /**
     * Method to test SequentialIterator
     */
    public static void main(String args[]) {
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 6;       
	    SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	    speciesSpheres.setNMolecules(nAtoms);
	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator iterator = iteratorFactory.makeGroupIteratorSequential();
	    iterator.setBasis(phase.getAgent(speciesSpheres));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		iterator.reset();
		int k = 0;
		while(iterator.hasNext()) {
		    Atom a = iterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of SequentialIterator.main
    
}//end of SequentialIterator
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates among the children of a given basis, those atoms
 * that are cell-list neighbors of a specified atom that is
 * a child of the same basis.
 */
//would like to modify so that central atom can be any descendant of the basis.
public static final class IntragroupNbrIterator extends AtomIterator {
    
    public IntragroupNbrIterator(IteratorFactoryCell factory) {
        iteratorFactory = factory;
    }
    
	public void all(AtomSet basis, IteratorDirective id, final AtomSetActive action) {
		 if(!(basis instanceof Atom && action instanceof AtomAction)) return;
		 all((Atom)basis, id, (AtomActive)action);
	}
    
	public void all(Atom basis, IteratorDirective id, final AtomActive action) {
		if(basis == null || basis.node.isLeaf() || action == null) return;
		throw new etomica.exception.MethodNotImplementedException();
	}

    /**
     * Indicates if another iterate is forthcoming.
     */
    public boolean hasNext() {return listIterator.hasNext();}
    
    /**
     * True if the parent group of the given atom is the current basis for the iterator.
     * False otherwise, or if atom or basis is null.
     */
    public boolean contains(Atom atom) {
        return atom != null && basis != null && atom.node.parentNode() == basis;
    }
    
    /**
     * Sets to state in which hasNext is false.
     */
    public void unset() {listIterator.unset();}
    
    /**
     * Does reset if atom in iterator directive is child of the current basis.  
     * Sets hasNext false if given atom does is not child of basis.  Throws
     * an IllegalArgumentException if directive does not specify an atom.
     */
    public Atom reset(IteratorDirective id) {
        direction = id.direction();
        return doReset(id.atom1());
    }
    
    //we assume that the only Tab links in the list are those demarking
    //the beginning of each cell's sequence; thus we reset the list iterator
    //using null as the terminator
    
    public Atom reset(Atom atom) {
        return doReset(atom);
    }
    
    private Atom doReset(Atom atom) {
        referenceAtom = atom;
        if(atom == null) 
            throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");

//        direction = IteratorDirective.BOTH; //why was this ever here?

        //probably need isDescendedFrom instead of parentGroup here
        if(atom.node.parentNode() != basis) {
            throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator referencing an atom not in group of basis");
        }
        if(iterateCells) {
            referenceCell = ((NeighborSequencer)atom.seq).cell();
            cellIterator.setBasis(referenceCell);
        }
        return doReset();
    }
    
    private Atom doReset() {
        listIterator.setSkipFirstAtom(true);
        upListNow = direction.doUp();
        doGoDown = direction.doDown();
        if(iterateCells) {
            listIterator.unset();
            if(upListNow) {
                cellIterator.reset(IteratorDirective.UP);//set cell iterator to return first up-neighbor of reference cell
                listIterator.reset(((NeighborSequencer)referenceAtom.seq).nbrLink, null, IteratorDirective.UP);
            }
            if(!listIterator.hasNext()) advanceCell();
        } else {//no cell iteration
            listIterator.reset(referenceAtom.seq, direction);
        }
        return listIterator.peek();
    }
    // Moves to next cell that has an iterate
    private void advanceCell() {
        do {
            if(cellIterator.hasNext()) {
                listIterator.setSkipFirstAtom(false);
                Atom cell = cellIterator.next();
                AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
                if(upListNow) {
                    listIterator.reset(tabs[tabIndex], null, IteratorDirective.UP);
                } else {
                    listIterator.reset(tabs[tabIndex].nextTab, null, IteratorDirective.DOWN);
                }
            } else if(doGoDown) {//no more cells that way; see if should now reset to look at down-cells
                listIterator.setSkipFirstAtom(true);
                cellIterator.reset(IteratorDirective.DOWN);//set cell iterator to return first down neighbor of reference cell
                listIterator.reset(((NeighborSequencer)referenceAtom.seq).nbrLink, null, IteratorDirective.DOWN);
                upListNow = false;
                doGoDown = false;
            } else {//no more cells at all
                break;
            }
        } while(!listIterator.hasNext());
    }

    /**
     * Performs given action for each child atom of basis.
     */
    public void allAtoms(AtomAction act) {
        doReset();
        if(iterateCells) {
            while(listIterator.hasNext()) {
                listIterator.allAtoms(act);
                advanceCell();
            }
        } else {
            listIterator.allAtoms(act);
        }
    }
            
    public Atom next() {
        Atom atom = listIterator.next();
        if(!listIterator.hasNext() && iterateCells) advanceCell();
        return atom;
    }
    
    /**
     * Throws RuntimeException because this is a neighbor iterator, and must
     * be reset with reference to an atom.
     */
    public Atom reset() {
        throw new RuntimeException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");
    }
    
    /**
     * Sets the given atom as the basis, so that child atoms of the
     * given atom will be returned upon iteration.  If given atom is
     * a leaf atom, a class-cast exception will be thrown.
     */
    public void setBasis(Atom atom) {
        setBasis((AtomTreeNodeGroup)atom.node);
    }
    
    //may be room for efficiency here
    public void setBasis(AtomTreeNodeGroup node) {
        basis = node;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setBasis(AtomList.NULL);
            iterateCells = false;
            return;
        }
        //can base decision whether to iterate over cells on type of sequencer
        //for given atom, because it is in the group of atoms being iterated
        iterateCells = basis.childSequencerClass().equals(NeighborSequencer.class);
        BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
        listIterator.setBasis(node.childList);
        if(iterateCells) {
            HashMap hash = (HashMap)lattice.agents[0];
            tabIndex = ((Integer)hash.get(node)).intValue();
        }
    }
    
    /**
     * Returns the current iteration basis.
     */
    public Atom getBasis() {return (basis != null) ? basis.atom() : null;}
    
    /**
     * The number of atoms in the current basis.  This will differ from
     * the number of iterates given by the iterator, because the iterator
     * will return only those atoms neighboring a reference atom, which
     * in general is not all the atoms in the basis.
     */
    public int size() {
       return (basis != null) ? basis.childAtomCount() : 0;
    }   

    private AtomTreeNodeGroup basis;
    private Atom next;
    private Atom referenceAtom;
    private boolean upListNow, doGoDown;
    private IteratorDirective.Direction direction = IteratorDirective.BOTH;
    private AbstractCell referenceCell;
    private boolean iterateCells;
    private int tabIndex;
    private BravaisLattice lattice;
    private final SiteIteratorNeighbor cellIterator = new SiteIteratorNeighbor();
    private final AtomIteratorList listIterator = new AtomIteratorList();
    private final IteratorFactoryCell iteratorFactory;

    /**
     * Method to test IntragroupNbrIterator
     */
    public static void main(String args[]) {
        Default.ATOM_SIZE = 1.0;
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 5;       
	    SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	    speciesSpheres.setNMolecules(nAtoms);
	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator sequenceIterator = iteratorFactory.makeGroupIteratorSequential();
	    AtomIterator iterator = iteratorFactory.makeIntragroupNbrIterator();
	    sequenceIterator.setBasis(phase.getAgent(speciesSpheres));
	    iterator.setBasis(phase.getAgent(speciesSpheres));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		sequenceIterator.reset();
		int k = 0;
		while(sequenceIterator.hasNext()) {
		    Atom a = sequenceIterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
		System.out.println(" first: "+first.signature());
		System.out.println("middle: "+middle.signature());
		System.out.println("  last: "+last.signature());
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of IntragroupNbrIterator.main

}//end of IntragroupNbrIterator class

/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates among the children of a given basis, those atoms
 * that are cell-list neighbors of a specified atom that is
 * a child of a different basis.
 */
//would like to modify so that central atom can be any descendant of the basis.
public static final class IntergroupNbrIterator extends AtomIterator {
    
    public IntergroupNbrIterator(IteratorFactoryCell factory) {
        iteratorFactory = factory;
    }
    
	public void all(AtomSet basis, IteratorDirective id, final AtomSetActive action) {
		 if(!(basis instanceof Atom && action instanceof AtomAction)) return;
		 all((Atom)basis, id, (AtomActive)action);
	}
    
	public void all(Atom basis, IteratorDirective id, final AtomActive action) {
		if(basis == null || basis.node.isLeaf() || action == null) return;
		throw new RuntimeException("Method all not implemented in IterfactoryCell.IntergroupNbrIterator");
	}

   /**
     * Indicates if another iterate is forthcoming.
     */
    public boolean hasNext() {return atomIterator.hasNext();}
    
    /**
     * True if the parent group of the given atom is the current basis for the iterator.
     * False otherwise, or if atom or basis is null.
     */
    public boolean contains(Atom atom) {
        return atom != null && basis != null && atom.node.parentNode() == basis;
    }
    
    /**
     * Sets iterators such that hasNext is false.
     */
    public void unset() {
        simpleIterator.unset();
        atomIterator = simpleIterator;
    }
    
    /**
     * Does reset if atom in iterator directive is child of the current basis.  
     * Sets hasNext false if given atom does is not child of basis.  Throws
     * an IllegalArgumentException if directive does not specify an atom.
     * Ignores direction.
     */
    public Atom reset(IteratorDirective id) {
        return doReset(id.atom1());
    }
    
    public Atom reset(Atom atom) {
        return doReset(atom);
    }
    
    //select iterators and set basis
    private Atom doReset(Atom atom) {
        if(atom == null) throw new IllegalArgumentException("Cannot reset IteratorFactoryCell.IntragroupNbrIterator without referencing an atom");

        if(basisIterateCells) {
            AbstractCell referenceCell = ((CellSequencer)atom.seq).cell();
            iterateCells = (referenceCell != null);
            if(iterateCells) simpleIterator.setBasis(referenceCell.neighborManager().neighbors());
        } else {
            iterateCells = false;
        }
        
        if(iterateCells) {//simple iterator is cell iterator
            listIterator.setBasis(basis);
            atomIterator = listIterator;
        } else { //simple iterator is atom iterator
            simpleIterator.setBasis(basis.childList);
            atomIterator = simpleIterator;
        }
        
        //reset iterators
        return doReset();
    }
    
    private Atom doReset() {
        if(iterateCells) {
            simpleIterator.reset();//reset cell iterator
            advanceCell();//reset list iterator
            return listIterator.peek();
        } else {//no cell iteration
            return simpleIterator.reset();
        }
    }
    
    // Moves to next cell that has an iterate
    private void advanceCell() {
        do {
            if(simpleIterator.hasNext()) {//cell iterator
                Atom cell = simpleIterator.next();
                AtomLinker.Tab[] tabs = (AtomLinker.Tab[])cell.agents[0];
                listIterator.reset(tabs[tabIndex], null, IteratorDirective.UP);
            } else {//no more cells at all
                break;
            }
        } while(!listIterator.hasNext());
    }

    /**
     * Performs given action for each child atom of basis.
     */
    public void allAtoms(AtomAction act) {
        doReset();
        if(iterateCells) {
            while(listIterator.hasNext()) {
                listIterator.allAtoms(act);
                advanceCell();
            }
        } else {
            simpleIterator.allAtoms(act);
        }
    }
            
    public Atom next() {
        Atom atom = atomIterator.next();
        if(!listIterator.hasNext() && iterateCells) advanceCell();
        return atom;
    }
    
    /**
     * Throws RuntimeException because this is a neighbor iterator, and must
     * be reset with reference to an atom.
     */
    public Atom reset() {
        throw new RuntimeException("Cannot reset IteratorFactoryCell.IntergroupNbrIterator without referencing an atom");
    }
    
    /**
     * Sets the given atom as the basis, so that child atoms of the
     * given atom will be returned upon iteration.  If given atom is
     * a leaf atom, a class-cast exception will be thrown.
     */
    public void setBasis(Atom atom) {
        setBasis((AtomTreeNodeGroup)atom.node);
    }
    
    //may be room for efficiency here
    public void setBasis(AtomTreeNodeGroup node) {
        basis = node;
        if(basis == null || basis.childAtomCount() == 0) {
            listIterator.setBasis(AtomList.NULL);
            basisIterateCells = false;
            return;
        }
        basisIterateCells = basis.childSequencerClass().equals(NeighborSequencer.class);
        BravaisLattice lattice = iteratorFactory.getLattice(basis.parentPhase());
        listIterator.setBasis(node.childList);
        if(basisIterateCells) {
            HashMap hash = (HashMap)lattice.agents[0];
            tabIndex = ((Integer)hash.get(node)).intValue();
        }
    }
    
    /**
     * Returns the current iteration basis.
     */
    public Atom getBasis() {return basis.atom();}
    
    /**
     * The number of atoms in the current basis.  This will differ from
     * the number of iterates given by the iterator, because the iterator
     * will return only those atoms neighboring a reference atom, which
     * in general is not all the atoms in the basis.
     */
    public int size() {
       return (basis != null) ? basis.childAtomCount() : 0;
    }   

    private AtomTreeNodeGroup basis;
    private Atom next;
    private boolean basisIterateCells, iterateCells;
    private int tabIndex;
    private BravaisLattice lattice;
    private final AtomIteratorList listIterator = new AtomIteratorList();
    private final AtomIteratorListSimple simpleIterator = new AtomIteratorListSimple();
    private final IteratorFactoryCell iteratorFactory;
    private AtomIterator atomIterator;//set to iterator that provides the atoms

    /**
     * Method to test IntergroupNbrIterator
     */
    public static void main(String args[]) {
        Default.ATOM_SIZE = 1.0;
        Simulation sim = new Simulation(new Space2D());

        IteratorFactoryCell iteratorFactory = new IteratorFactoryCell(sim);
        sim.setIteratorFactory(iteratorFactory);
        int nAtoms = 50;       
	    SpeciesSpheresMono speciesSpheres1 = new SpeciesSpheresMono();
	    SpeciesSpheresMono speciesSpheres2 = new SpeciesSpheresMono();
	    speciesSpheres1.setNMolecules(nAtoms);
	    speciesSpheres2.setNMolecules(nAtoms);
//	    Potential potential = new P2HardSphere();
	    Phase phase = new Phase();
	    IntegratorHard integrator = new IntegratorHard();
        integrator.setTimeStep(0.01);
        Controller controller = new Controller();
		Simulation.instance.elementCoordinator.go();
		System.out.println("Starting MD");
		integrator.setMaxSteps(100);
		integrator.initialize();
		integrator.run();
		System.out.println("Done");
		
		
	    BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    AtomIterator sequenceIterator = iteratorFactory.makeGroupIteratorSequential();
	    AtomIterator iterator = iteratorFactory.makeIntergroupNbrIterator();
	    sequenceIterator.setBasis(phase.getAgent(speciesSpheres1));
	    iterator.setBasis(phase.getAgent(speciesSpheres2));
		Atom first = null;
		Atom middle = null;
		Atom last = null;
		sequenceIterator.reset();
		int k = 0;
		while(sequenceIterator.hasNext()) {
		    Atom a = sequenceIterator.next();
		    if(k == 0) first = a;
		    else if(k == nAtoms/2) middle = a;
		    else if(k == nAtoms-1) last = a;
		    k++;
		}
		System.out.println(" first: "+first.signature());
		System.out.println("middle: "+middle.signature());
		System.out.println("  last: "+last.signature());
	    
	    IteratorDirective.testSuite(iterator, first, middle, last);
	    
    }//end of IntergroupNbrIterator.main

}//end of IntergroupNbrIterator class

/////////////////////////////////////////////////////////////////////////////////////////////

public interface CellSequencer {
    
    /**
     * Method called to notify sequencer that the phase has a new cell lattice.
     */
    public void latticeChangeNotify();
    
    public AbstractCell cell();
    
}//end of CellSequencer interface
   
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Sequencer used for atoms that are not being neighbor listed.
 */
public static final class SimpleSequencer extends AtomSequencer implements CellSequencer {
    
    public SimpleSequencer(Atom a) {super(a);}
    
    /**
     * CellSequencer interface method; performs no action except to pass event
     * on to sequencers of child atoms.
     */
    public void latticeChangeNotify() {
        if(atom.node.isLeaf()) return;
        else {
            AtomIteratorListSimple iterator = new AtomIteratorListSimple(((AtomTreeNodeGroup)atom.node).childList);
            while(iterator.hasNext()) ((CellSequencer)atom.seq).latticeChangeNotify();
        }
    }
    
    public AbstractCell cell() {
        Atom parent = atom.node.parentGroup();
        return (parent != null) ? ((CellSequencer)parent.seq).cell() : null;
    }

    /**
     * Performs no action.
     */
    public void moveNotify() {}
    
    /**
     * Performs no action.
     */
    public void setParentNotify(AtomTreeNodeGroup newParent) {}
    
    /**
     * Returns true if this atom preceeds the given atom in the atom sequence.
     * Returns false if the given atom is this atom, or (of course) if the
     * given atom instead preceeds this one.  Returns true if the given atom is null.
     */
    public boolean preceeds(Atom a) {
//        throw new RuntimeException("IteratorFactoryCell.Sequencer.preceeds method should be checked for correctness before using");
//        //want to return false if atoms are the same atoms
        if(a == null) return true;
        if(atom.node.parentNode() == a.node.parentNode()) return atom.node.index() < a.node.index();//works also if both parentGroups are null
        int thisDepth = atom.node.depth();
        int atomDepth = a.node.depth();
        if(thisDepth == atomDepth) return atom.node.parentGroup().seq.preceeds(a.node.parentGroup());
        else if(thisDepth < atomDepth) return this.preceeds(a.node.parentGroup());
        else /*this.depth > atom.depth*/ return atom.node.parentGroup().seq.preceeds(a);
    }
    
    public static final AtomSequencer.Factory FACTORY = new AtomSequencer.Factory() {
        public AtomSequencer makeSequencer(Atom atom) {
            return new SimpleSequencer(atom);
        }
        public Class sequencerClass() {return SimpleSequencer.class;}
    };
}

/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Sequencer used for atoms being neighbor listed.
 */

public static final class NeighborSequencer extends AtomSequencer implements CellSequencer {
    
    public AbstractCell cell;         //cell currently occupied by this coordinate
    public BravaisLattice lattice;    //cell lattice in the phase occupied by this coordinate
    private int listIndex;
    public final AtomLinker nbrLink;  //linker used to arrange atom in sequence according to cells
    
    public NeighborSequencer(Atom a) {
        super(a);
        nbrLink = new AtomLinker(a);
    }
    
    //CellSequencer interface method
    public void latticeChangeNotify() {
        this.assignCell();
        if(atom.node.isLeaf()) return;
        else {
            AtomIteratorListSimple iterator = new AtomIteratorListSimple(((AtomTreeNodeGroup)atom.node).childList);
            while(iterator.hasNext()) ((CellSequencer)atom.seq).latticeChangeNotify();
        }
    }

    //CellSequencer interface method
    public AbstractCell cell() {return cell;}

    public int listIndex() {return listIndex;}

    public void remove() {
        super.remove();
        nbrLink.remove();
    }
        
    public void addBefore(AtomLinker newNext) {
        //newNext will never be one of the cell tabs
        super.addBefore(newNext);
        if(lattice != null) assignCell();
        else nbrLink.remove();
        
    /*    while(newNext.atom == null && newNext != this) newNext = newNext.next;
        if(newNext == this) {//this is the first and only non-tab entry in the list
            nextFixed = previousFixed = this;
            return;
        }
        nextFixed = (Sequencer)newNext;
        previousFixed = nextFixed.previousFixed;
        previousFixed.nextFixed = this;
        nextFixed.previousFixed = this;*/
	}
	/**
	 * Reshuffles position of "neighbor" links without altering the regular links.
	 */
	public void moveBefore(AtomLinker newNext) {
	    nbrLink.moveBefore(newNext);
	}


    /**
     * Returns true if this atom preceeds the given atom in the atom sequence.
     * Returns false if the given atom is this atom, or (of course) if the
     * given atom instead preceeds this one.
     */
     //this method needs to be fixed
    public boolean preceeds(Atom a) {
        throw new RuntimeException("IteratorFactoryCell.CellSequencer.preceeds method not yet implemented");
        //want to return false if atoms are the same atoms
      /*  if(a == null) return true;
        if(atom.node.parentGroup() == a.node.parentGroup()) {
            if(((Sequencer)atom.seq).site().equals(cell)) {
                //this isn't correct
                return atom.node.index() < a.node.index();//works also if both parentGroups are null
            }
            else return ((Sequencer)atom.seq).site().preceeds(cell);
        }
        int thisDepth = atom.node.depth();
        int atomDepth = a.node.depth();
        if(thisDepth == atomDepth) return atom.node.parentGroup().seq.preceeds(a.node.parentGroup());
        else if(thisDepth < atomDepth) return this.preceeds(a.node.parentGroup());
        else /*if(this.depth > atom.depth)* / return atom.node.parentGroup().seq.preceeds(a);
        */
    }
    
    /**
     * Method called when a translate method of coordinate is invoked.
     */
    public void moveNotify() {
    //    if(!cell.inCell(atom.coord.position())) assignCell();
        assignCell();
    }
    
    /**
     * Method called when the parent of the atom is changed.
     * By the time this method is called, the atom has been placed
     * in the childList of the given parent (if it is not null).
     */
    public void setParentNotify(AtomTreeNodeGroup newParent) {
        if(newParent == null || newParent instanceof AtomReservoir.ReservoirAtomTreeNode) {
            cell = null;
            lattice = null;
            return;
        }
        //get cell lattice for the phase containing the parent
        lattice = ((IteratorFactoryCell)newParent.parentSimulation().iteratorFactory).getLattice(newParent.parentPhase());
        //determine the index used by the cells for their tabs in the parent's childList
        HashMap hash = (HashMap)lattice.agents[0];
        Integer index = (Integer)hash.get(newParent);
        if(index == null) {//parent's childList isn't yet represented by cells
            index = new Integer(hash.size());
            hash.put(newParent, index);
            setupListTabs(lattice/*, newParent.childList*/);
        }
        listIndex = index.intValue();
        assignCell();
    }

//Determines appropriate cell and assigns it
    public void assignCell() {
        int[] latticeIndex = lattice.getPrimitive().latticeIndex(atom.coord.position(), lattice.getDimensions());
        AbstractCell newCell = (AbstractCell)lattice.site(latticeIndex);
        if(newCell != cell) {assignCell(newCell);}
    }
//Assigns atom to given cell
    public void assignCell(AbstractCell newCell) {
        cell = newCell;
        if(cell == null) return;
        this.moveBefore(((AtomLinker.Tab[])newCell.agents[0])[listIndex].nextTab);
    }//end of assignCell
    
    public static final AtomSequencer.Factory FACTORY = new AtomSequencer.Factory() {
        public AtomSequencer makeSequencer(Atom atom) {return new NeighborSequencer(atom);}
        public Class sequencerClass() {return NeighborSequencer.class;}
    };
}//end of NeighborSequencer

/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Iterates through the cells of the given lattice, and adds a tab to the 
 * given list for each cell, and extends the tablist in each cell to reference
 * its new tab.
 */
private static void setupListTabs(BravaisLattice lattice/*, AtomList list*/) {
    AtomIteratorList iterator = new AtomIteratorList(lattice.siteList());
    iterator.reset();
    AtomLinker.Tab[] headerList = null;
    while(iterator.hasNext()) {//loop over cells
        Site site = (Site)iterator.next();
        if(site.agents == null || site.agents[0] == null) {
            site.agents = new Object[1];
            site.agents[0] = new AtomLinker.Tab[0];
        }
        AtomLinker.Tab[] tabList = (AtomLinker.Tab[])site.agents[0];
        AtomLinker.Tab[] newTabList = new AtomLinker.Tab[tabList.length+1];
        for(int i=0; i<tabList.length; i++) newTabList[i] = tabList[i];
        AtomLinker.Tab newTab = new AtomLinker.Tab();
        newTabList[tabList.length] = newTab;
        if(headerList == null) headerList = newTabList;
        else newTab.addBefore(headerList[tabList.length]);
 //       list.add(newTab);
        site.agents[0] = newTabList;
    }
}//end of setupListTabs

    /**
     * Demonstrates how this class is implemented.
     */
    public static void main(String[] args) {
        
  //      SequentialIterator.main(args); 
  //      IntragroupNbrIterator.main(args); 
  //      IntergroupNbrIterator.main(args); 
        boolean cellListing = true;
        boolean doDisplay = true;
        boolean md = true;
        int nAtoms = 90;
        boolean fixedLengthRun = false;
        boolean mixture = false;
        
        System.out.println(cellListing ? "cellListing" : "no cellListing");
        System.out.println(md ? "md" : "mc");
        System.out.println("number of atoms in simulation: "+2*nAtoms);
        
        Default.ATOM_SIZE = 150./(double)nAtoms;
        etomica.graphics.SimulationGraphic sim = new etomica.graphics.SimulationGraphic(new Space2D());
        Simulation.instance = sim;

        if(cellListing) sim.setIteratorFactory(new IteratorFactoryCell(sim));
        
        Integrator integrator = null;
        if(md) {
	        integrator = new IntegratorHard();
            ((IntegratorHard)integrator).setTimeStep(0.01);
        } else {
            integrator = new IntegratorMC();
            MCMoveAtom mcMoveAtom = new MCMoveAtom((IntegratorMC)integrator);
            //MCMoveVolume mcMoveVolume = new MCMoveVolume((IntegratorMC)integrator);
            //mcMoveVolume.setPressure(3.0);
        }
        
	    Controller controller = new Controller();
	    etomica.graphics.DisplayPhase displayPhase = null;
	    if(doDisplay) displayPhase = new etomica.graphics.DisplayPhase();

        if(!mixture) {
	        SpeciesSpheresMono speciesSpheres = new SpeciesSpheresMono();
	        speciesSpheres.setNMolecules(2*nAtoms);
	        if(doDisplay) etomica.graphics.ColorSchemeByType.setColor(speciesSpheres, java.awt.Color.green);
	    	    
	        Potential2 potential = new P2HardSphere();
	    } else {
	        SpeciesSpheresMono speciesSpheres1 = new SpeciesSpheresMono();
	        SpeciesSpheresMono speciesSpheres2 = new SpeciesSpheresMono();
	        speciesSpheres1.setNMolecules(nAtoms);
	        speciesSpheres2.setNMolecules(nAtoms);
	        if(doDisplay) {
	            etomica.graphics.ColorSchemeByType.setColor(speciesSpheres1, java.awt.Color.green);
	            etomica.graphics.ColorSchemeByType.setColor(speciesSpheres2, java.awt.Color.black);
	        }
	    	    
	        Potential2 potential11 = new P2HardSphere();
	        Potential2 potential12 = new P2HardSphere();
	    //  Potential2 potential12 = new P2SquareWell();
	        Potential2 potential22 = new P2HardSphere();
	        potential11.setSpecies(speciesSpheres1, speciesSpheres1);
	        potential12.setSpecies(speciesSpheres2, speciesSpheres1);
	        potential22.setSpecies(speciesSpheres2, speciesSpheres2);
        }
        
	    Phase phase = new Phase();//must come after species!
        
	    etomica.graphics.LatticeRenderer.ColorSchemeNeighbor colorSchemeNbr = null; 
	    etomica.graphics.LatticeRenderer.ColorSchemeCell colorSchemeCell = null;
        if(doDisplay) {
            if(cellListing) {
	            colorSchemeNbr = new etomica.graphics.LatticeRenderer.ColorSchemeNeighbor(sim);
	            colorSchemeCell = new etomica.graphics.LatticeRenderer.ColorSchemeCell();
	        }
	    }
    	    
	    integrator.setDoSleep(false);
	    integrator.setSleepPeriod(2);
	    
	    
        //this method call invokes the mediator to tie together all the assembled components.
		Simulation.instance.elementCoordinator.go();
		
		if(cellListing) {

	        BravaisLattice lattice = ((IteratorFactoryCell)sim.getIteratorFactory()).getLattice(phase);
	    //    ((IteratorFactoryCell)sim.iteratorFactory).setNeighborRange(4.0);
    	
	        if(doDisplay) {
	            //draw lattice cells on display
	    //      etomica.graphics.LatticeRenderer latticeRenderer = 
	    //              new etomica.graphics.LatticeRenderer(lattice);
	    //      displayPhase.addDrawable(latticeRenderer);
    	  
	            //color atoms
	            colorSchemeNbr.setAtom(phase.speciesMaster.atomList.getRandom());
	            displayPhase.setColorScheme(colorSchemeNbr);
        //        colorSchemeCell.setLattice(lattice);
        //	    displayPhase.setColorScheme(colorSchemeCell);
            }
        }
        
        if(doDisplay) etomica.graphics.SimulationGraphic.makeAndDisplayFrame(sim);
        
        if(fixedLengthRun) {
            if(md) integrator.setMaxSteps(1000);
            else   integrator.setMaxSteps(100*nAtoms*2);
        }
        integrator.initialize();
        System.out.println("Starting");
//        etomica.benchmark.Stopwatch timer = new etomica.benchmark.Stopwatch().start();
//        integrator.run();
//        timer.stop();
//        System.out.println("Elapsed time: "+0.001*timer.getElapsedTime());
        
     //   controller.start();
    }//end of main
    
    
   
}//end of IteratorFactoryCell