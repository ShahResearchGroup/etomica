package simulate;

public final class AtomPair implements Cloneable{
    public Atom atom1, atom2;
    public final Space.CoordinatePair cPair;
//    public Potential potential;
    public AtomPair(Phase phase) {
        cPair = phase.space().makeCoordinatePair(phase.boundary());
    }
    public AtomPair(Atom a1, Atom a2) {  //Assumes a1 and a2 are in same phase
        cPair = a1.parentPhase().space().makeCoordinatePair(a1.parentPhase().boundary());
        reset(a1, a2);
    }
    public AtomPair(Atom a1, Atom a2, Space.CoordinatePair c) {atom1 = a1; atom2 = a2; cPair = c;}
    
    /**
     * Clones this atomPair without cloning the atoms or their coordinates
     * The returned atomPair refers to the same pair of atoms as the original
     * This can be used to make a working copy of an atomPair that is returned by an atomPair iterator
     * Method is called "copy" instead of "clone" because whole object tree isn't cloned
     */
    public AtomPair copy() {
        return new AtomPair(atom1, atom2, cPair.copy());  //cannot use super.clone() becuase cPair (being final) cannot then be changed to a clone of cPair
    }

    public void reset(Atom a1, Atom a2) {
        atom1 = a1; 
        atom2 = a2;
        reset();
    }
    public void reset() {
        cPair.reset(atom1.coordinate(), atom2.coordinate());
    }
    public final double r2() {return cPair.r2();}
    public final double v2() {return cPair.v2();}
    public final double vDotr() {return cPair.vDotr();}
    public final double dr(int i) {return cPair.dr(i);}
    public final double dv(int i) {return cPair.dv(i);}
    public final Atom atom1() {return atom1;}
    public final Atom atom2() {return atom2;}
    
    /**
     * Sorts by separation distance all the atom pairs produced by an atomPair iterator
     * Returns the first element of a linked list of atomPair(Linker)s, sorted by increasing distance
     * Perhaps better to do this using java.util.Collections (in java 1.2 API)
     */
    public static AtomPair.Linker distanceSort(AtomPair.Iterator api) {
        if(!api.hasNext()) return null;
        AtomPair.Linker firstLink = new AtomPair.Linker(api.next().copy());
        while(api.hasNext()) {                      //loop through all pairs generated by api
            AtomPair nextPair = api.next().copy();  //make a copy of pair for use in ordered list
            //Insert pair into ordered list in proper location
            Linker previous = null;  //holds value from previous iteration of this for-loop
            boolean inserted = false;
            for(Linker link=firstLink; link!=null; link=link.next()) {
                if(nextPair.r2() < link.pair().r2()) {  //insert nextPair before current pair
                    if(previous == null) {firstLink = new Linker(nextPair,firstLink);} //nextPair is new firstPair, to be followed by old firstPair
                    else {previous.setNext(new Linker(nextPair,link));}  //place nextPair between last and pair
                    inserted = true;
                    break;  //break out of for-loop
                }
                previous = link;
            }  //end of for loop
            if(!inserted) //reached end of list without inserting;
                previous.setNext(new Linker(nextPair));   //insert after last link
        }
        return firstLink;
    }
    
    /**
     * Interface for classes that generate atom pairs according to various criteria
     */
    public interface Iterator {
        
        public boolean hasNext();
        public AtomPair next();
//        public void reset();
        
        public interface M extends Iterator {public void reset(Molecule m);}
        public interface A extends Iterator {  
//            public void allDone();
            public void reset(Atom a, boolean intra);
        }
        
        /**
         * Iterator for all atom pairs in a phase
         * Default is to do inter and intra pairs; this may be overridden using reset method to do
         * only intermolecular pairs
         * Uses atom iterator and atomPair iterator given by the phase.iterator class.
         */
         public static class All implements Iterator {
            private Iterator.A apiUp, apiReserve;
            private final Atom.Iterator atomUp;
            private boolean intra;
            private boolean hasNext;
            private AtomPair thisPair;
            public All(Phase p) {
                apiUp = p.iterator.makeAtomPairIteratorUp();
                apiReserve = p.iterator.makeAtomPairIteratorUp();
                atomUp = p.iterator.makeAtomIteratorUp();
                reset(true);
            }
            public boolean hasNext() {return hasNext;}
            public AtomPair next() {
                thisPair = apiUp.next();  //need to take care not to advance apiUp again before return
                if(!apiUp.hasNext()) {    //if so, this is last pair for current atom
                    do {                  //advance up list of atoms until one with a pair is found
                        if(atomUp.hasNext()) {apiReserve.reset(atomUp.next(),intra);}  //work with apiReserve so not to change pair of apiUp
                        else {hasNext = false; return thisPair;}}   //end of list of atoms; no more pairs after this one
                    while(!apiReserve.hasNext());
                    Iterator.A temp = apiUp;      //apiReserve is ready to serve another pair
                    apiUp = apiReserve;           // so swap handle with apiUp
                    apiReserve = temp;            // (this doesn't advance apiUp, so it is safe)
                }
                return thisPair;
            }
            public void reset() {reset(intra);}
            public void reset(boolean i) {
                intra = i;
                atomUp.reset();
                do {  //advance up list of atoms until one with a pair is found
                    if(atomUp.hasNext()) {apiUp.reset(atomUp.next(),intra);}
                    else {hasNext = false; return;}}   //end of list of atoms
                while(!apiUp.hasNext());
                hasNext = true;
            }
         }
                
        /**
         * Iterator for all atoms in a molecule with all atoms in a phase
         * The molecule may or may not be in the phase
         * Intramolecular pairs are not generated
         */
         // Needs to be fixed to handle multi-atom molecules
        public static class MP implements M {
            private final Iterator.A apiUp, apiDown;
            private Iterator.A apiCurrent;
            private boolean hasNext, upDone;
            private AtomPair thisPair;
            public MP(Phase p) {
                apiUp = p.iterator.makeAtomPairIteratorUp();
                apiDown = p.iterator.makeAtomPairIteratorDown();
                hasNext = false;
            }
            public MP(Phase p, Molecule m) {
                apiUp = p.iterator.makeAtomPairIteratorUp();
                apiDown = p.iterator.makeAtomPairIteratorDown();
                reset(m);
            }
            public boolean hasNext() {return hasNext;}
            public AtomPair next() {
                thisPair = apiCurrent.next();
                if(!apiCurrent.hasNext()) {
                    if(upDone) {hasNext = false;}  //all done
                    else {                         //switch to down iterator
                        apiCurrent = apiDown;
                        upDone = true;
                        hasNext = apiCurrent.hasNext();
                    }
                }
                return thisPair;
            }
            public void reset(Molecule m) {
                apiUp.reset(m.lastAtom(),false);     //may be missing atoms on molecule between first and last
                apiDown.reset(m.firstAtom(),false);
                if(apiUp.hasNext()) {
                    apiCurrent = apiUp;
                    upDone = false;}
                else {
                    apiCurrent = apiDown;
                    upDone = true;
                }
                hasNext = apiCurrent.hasNext();
            }
        }
                    
  // Iterates over pairs formed by given atom and all atoms from other molecules above it in list
 // If given atom is not in phase, it is considered the last atom, and no iterations are performed
        public static final class Up implements Iterator.A {
            private final AtomPair pair;
            private final Phase phase;
            private boolean hasNext;
            private Atom nextAtom;
            public Up(Phase p) {phase = p; pair = new AtomPair(p); hasNext = false;}
            public Up(Phase p, Atom a) {phase = p; pair = new AtomPair(p); reset(a,true);}
            public void allDone() {hasNext = false;}
            public boolean hasNext() {return hasNext;}
            public void reset(Atom a, boolean intra) {
                if(a == null || a.parentPhase() != phase) {hasNext = false; return;}
                pair.atom1 = a;
                nextAtom = intra ? a.nextAtom() : a.nextMoleculeFirstAtom();
                hasNext = (nextAtom != null);
            }
            public AtomPair next() {
                pair.atom2 = nextAtom;
                pair.reset();
                nextAtom = nextAtom.nextAtom();
                hasNext = (nextAtom != null);
                return pair;
            }
        } //end of AtomPair.Iterator.Up
 
    /**
     * Iterates over pairs formed by given atom and all atoms from other molecules below it in list
     * If given atom is not in phase, it is considered the last atom, and iterations are performed over
     * all atoms in phase
     */
    
        public static final class Down implements Iterator.A {
            private final AtomPair pair;
            private final Phase phase;
            private boolean hasNext;
            private Atom nextAtom;
            public Down(Phase p) {phase = p; pair = new AtomPair(p); hasNext = false;}
            public Down(Phase p, Atom a) {phase = p; pair = new AtomPair(p); reset(a,true);}
            public boolean hasNext() {return hasNext;}
            public void allDone() {hasNext = false;}
            public void reset(Atom a, boolean intra) {
                if(a == null) {hasNext = false; return;}
                pair.atom1 = a;
                if(a.parentPhase() == phase) {
                    nextAtom = intra ? a.previousAtom() : a.previousMoleculeLastAtom();}
                else {
                    nextAtom = phase.lastAtom();
                }
                hasNext = (nextAtom != null);
            }
            public AtomPair next() {
                pair.atom2 = nextAtom;
                pair.reset();
                nextAtom = nextAtom.previousAtom();
                hasNext = (nextAtom != null);
                return pair;
            }
        } //end of AtomPair.Iterator.Down
        
    }  //end of interface Iterator
    
    public static class Linker {
        private AtomPair pair;
        private AtomPair.Linker next;
        public Linker() {}
        public Linker(AtomPair p) {pair = p;}
        public Linker(AtomPair p, Linker l) {pair = p; next = l;}
        public final AtomPair pair() {return pair;}
        public final AtomPair.Linker next() {return next;}
        public final void setNext(AtomPair.Linker l) {next = l;}
        public final void setPair(AtomPair p) {pair = p;}
    }
    
}  //end of  AtomPair